<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Sand Letters</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@1,700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: monospace;
      }
      #three-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        pointer-events: none; /* ë§ˆìš°ìŠ¤ ì…ë ¥ ì°¨ë‹¨ */
      }
      #canvas {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 2;
        cursor: text;
        pointer-events: none; /* ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ëŠ” windowì—ì„œ ë°›ìŒ */
      }
    </style>
  </head>
  <body>
    <div id="three-container"></div>
    <canvas id="canvas"></canvas>

    <script>
      // Three.js 3D ì”¬ ì„¤ì •
      const scene = new THREE.Scene();
      const floorColor = 0x1a1a1a; // ì•½ê°„ ë°ì€ ê²€ì€ìƒ‰
      scene.background = new THREE.Color(floorColor); // ë°°ê²½ê³¼ ë°”ë‹¥ ìƒ‰ìƒ í†µì¼
      scene.fog = new THREE.Fog(floorColor, 20, 100); // ì•ˆê°œ íš¨ê³¼ë¡œ ë¬´í•œ ëŠë‚Œ
      
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // ë°°ê²½ íˆ¬ëª… ê°€ëŠ¥í•˜ë„ë¡
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('three-container').appendChild(renderer.domElement);

      // ë¬´í•œ í™•ì¥ë˜ëŠ” ë°”ë‹¥ (ë§¤ìš° í¬ê²Œ)
      const roomSize = 200;
      const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
      const floorMaterial = new THREE.MeshStandardMaterial({ 
        color: floorColor,
        roughness: 0.9,
        metalness: 0.1
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -5;
      floor.receiveShadow = true;
      scene.add(floor);
      window.floorMesh = floor; // ë‚˜ì¤‘ì— ì œê±°í•  ìˆ˜ ìˆë„ë¡ ì €ì¥

      // GLB ë¨í”„ ëª¨ë¸ ë¡œë“œ
      const lampGroup = new THREE.Group();
      lampGroup.position.set(0, -5.0, 0); // ë°”ë‹¥ì— ë” ê°€ê¹Œì´
      scene.add(lampGroup);
      
      // GLTFLoaderë¡œ GLB íŒŒì¼ ë¡œë“œ
      const loader = new THREE.GLTFLoader();
      loader.load('alladins_lamp.glb', 
        function(gltf) {
          console.log('âœ¨ Lamp model loaded!');
          const lampModel = gltf.scene;
          
          // í¬ê¸° ì¡°ì • (ì ë‹¹í•œ í¬ê¸°)
          lampModel.scale.set(12.0,   12.0, 12.0);
          
          // íšŒì „ (180ë„)
          lampModel.rotation.y = Math.PI;
          
          // ê·¸ë¦¼ì ì„¤ì •
          lampModel.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          
          lampGroup.add(lampModel);
        },
        function(xhr) {
          console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        },
        function(error) {
          console.error('âŒ Error loading lamp model:', error);
        }
      );

      // ì¡°ëª… ì„¤ì • (ë°ê²Œ)
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); // 0.5 â†’ 1.2
      scene.add(ambientLight);

      // ë¨í”„ì—ì„œ ë‚˜ì˜¤ëŠ” ë°ì€ ë¹›
      const lampLight = new THREE.PointLight(0xffffff, 8, 60); // 4 â†’ 8
      lampLight.position.set(0, -4.5, 0); // ë¨í”„ ìœ„ì¹˜ì— ë§ì¶¤
      scene.add(lampLight);

      // ë©”ì¸ ì¡°ëª… (ì™¼ìª½ìœ¼ë¡œ 60ë„ íšŒì „, ë‚®ì€ ê°ë„)
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.5); // 0.9 â†’ 1.5
      mainLight.position.set(-3.3, 1.5, -6.7); // ì™¼ìª½ 60ë„, ë‚®ì€ ìœ„ì¹˜
      mainLight.target.position.set(0, -5, 0); // ë¨í”„ë¥¼ í–¥í•¨
      scene.add(mainLight.target);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 2048;
      mainLight.shadow.mapSize.height = 2048;
      mainLight.shadow.camera.left = -10;
      mainLight.shadow.camera.right = 10;
      mainLight.shadow.camera.top = 10;
      mainLight.shadow.camera.bottom = -10;
      mainLight.shadow.camera.near = 0.5;
      mainLight.shadow.camera.far = 20;
      scene.add(mainLight);

      // ì¹´ë©”ë¼ ì´ˆê¸° ìœ„ì¹˜ ì„¤ì •
      camera.position.set(1.98, -0.12, -4.35);
      camera.lookAt(0, -5, 0); // ë¨í”„ë¥¼ ë°”ë¼ë´„
      camera.fov = 95;
      camera.updateProjectionMatrix();
      
      // í‚¤ë³´ë“œ íšŒì „ìš© ë³€ìˆ˜ (OrbitControlsì™€ ë³„ë„)
      let cameraDistance = Math.sqrt(1.98*1.98 + 4.35*4.35);
      let cameraAngle = Math.atan2(-4.35, 1.98);
      let cameraHeight = -0.12;
      
      function updateCameraPosition() {
        camera.position.x = Math.cos(cameraAngle) * cameraDistance;
        camera.position.y = cameraHeight;
        camera.position.z = Math.sin(cameraAngle) * cameraDistance;
        camera.lookAt(0, -5, 0); // ë¨í”„ë¥¼ ë°”ë¼ë´„
      }
      
      
      // í‚¤ë³´ë“œ íšŒì „ì„ ìœ„í•œ ë³€ìˆ˜
      let isRotatingLeft = false;
      let isRotatingRight = false;
      let rotationVelocity = 0;
      const maxRotationSpeed = 0.03;
      const rotationAcceleration = 0.002;
      const rotationDeceleration = 0.001;
      
      // ì¹´ë©”ë¼ ì´ˆê¸° ìœ„ì¹˜ë¡œ ë³µê·€ (touch 3ë²ˆ ì‹œ)
      let isCameraReturning = false;
      let cameraReturnStartTime = 0;
      let cameraStartAngle = 0;
      let cameraTargetAngle = 0;
      
      // touch ì¹´ìš´í„° ë° ë¨í”„ ì• ë‹ˆë©”ì´ì…˜ ë³€ìˆ˜
      let touchCount = 0;
      let lampShaking = false;
      let lampShakeStartTime = 0;
      let currentTypedText = '';
      let wishMessage = null;
      let wishInputText = ''; // Make your wish ì´í›„ ì…ë ¥ë˜ëŠ” í‚¤ì›Œë“œ
      let explosionParticles = []; // ì£¼ë‘¥ì´ì—ì„œ í­ë°œí•˜ëŠ” íŒŒí‹°í´
      let isExploding = false;
      let explosionStartTime = 0;

      // Three.js ì• ë‹ˆë©”ì´ì…˜
      function animateThree() {
        requestAnimationFrame(animateThree);
        
        // ë¨í”„ ë¶ˆë¹›ì´ ì•„ì£¼ ì€ì€í•˜ê²Œ ê¹œë°•ì„
        lampLight.intensity = 2.5 + Math.sin(Date.now() * 0.0008) * 0.3;
        
        // ë¨í”„ í”ë“¤ë¦¼ ì• ë‹ˆë©”ì´ì…˜ (touch íšŸìˆ˜ì— ë”°ë¼ ì ì§„ì ìœ¼ë¡œ ê°•í•´ì§)
        if (lampShaking) {
          const elapsed = (Date.now() - lampShakeStartTime) / 1000; // ì´ˆ ë‹¨ìœ„
          
          // touch íšŸìˆ˜ì— ë”°ë¥¸ ê°•ë„ì™€ ì§€ì† ì‹œê°„ (1->2->3)
          const intensityMultiplier = touchCount * 0.4; // 0.4, 0.8, 1.2 (ì²«ë²ˆì§¸ ë” ì•½í•˜ê²Œ)
          const duration = touchCount === 1 ? 1.5 : (touchCount === 2 ? 2.5 : 4); // 1.5ì´ˆ, 2.5ì´ˆ, 4ì´ˆ
          
          if (elapsed < duration) {
            const t = elapsed / duration; // 0~1
            const shake = (1 - t); // ì ì  ì•½í•´ì§
            
            lampGroup.rotation.x = Math.sin(Date.now() * 0.008) * shake * 0.3 * intensityMultiplier;
            lampGroup.rotation.y = Math.sin(Date.now() * 0.011) * shake * 0.4 * intensityMultiplier;
            lampGroup.rotation.z = Math.sin(Date.now() * 0.009) * shake * 0.25 * intensityMultiplier;
          } else {
            // ì›ìœ„ì¹˜ë¡œ ë¶€ë“œëŸ½ê²Œ ë³µê·€
            lampGroup.rotation.x *= 0.85;
            lampGroup.rotation.y *= 0.85;
            lampGroup.rotation.z *= 0.85;
            
            if (Math.abs(lampGroup.rotation.x) < 0.01 && 
                Math.abs(lampGroup.rotation.y) < 0.01 && 
                Math.abs(lampGroup.rotation.z) < 0.01) {
              lampGroup.rotation.set(0, 0, 0);
              lampShaking = false;
              console.log('Lamp stopped shaking');
              
              // ì„¸ ë²ˆì§¸ touchì¼ ë•Œë§Œ ëª¨ë˜ë°”ëŒ ì‹œì‘
              if (touchCount === 3) {
                console.log('ğŸŒªï¸ Starting sand storm!');
                isExploding = true;
                explosionStartTime = Date.now();
              }
            }
          }
        }
        
        // ì¹´ë©”ë¼ ì´ˆê¸° ìœ„ì¹˜ë¡œ ë³µê·€ (touch 3ë²ˆ ì‹œ)
        if (isCameraReturning) {
          const returnDuration = 2.0; // 2ì´ˆì— ê±¸ì³ ë³µê·€
          const returnElapsed = (Date.now() - cameraReturnStartTime) / 1000;
          const returnProgress = Math.min(returnElapsed / returnDuration, 1.0);
          
          // ease-in-out í•¨ìˆ˜
          const easeInOut = returnProgress < 0.5 
            ? 2 * returnProgress * returnProgress 
            : 1 - Math.pow(-2 * returnProgress + 2, 2) / 2;
          
          // ê°ë„ ì°¨ì´ ê³„ì‚° (ìµœë‹¨ ê²½ë¡œë¡œ íšŒì „)
          let angleDiff = cameraTargetAngle - cameraStartAngle;
          // -PI ~ PI ë²”ìœ„ë¡œ ì •ê·œí™”
          while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
          while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
          
          cameraAngle = cameraStartAngle + angleDiff * easeInOut;
          updateCameraPosition();
          
          if (returnProgress >= 1.0) {
            isCameraReturning = false;
            console.log('ğŸ“¸ Camera returned to initial position');
          }
        }
        
        // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ íšŒì „ (ease in/out) - í‚¤ë³´ë“œ
        if (!isCameraReturning && (isRotatingLeft || isRotatingRight)) {
          // ê°€ì†
          if (isRotatingLeft) {
            rotationVelocity = Math.min(rotationVelocity + rotationAcceleration, maxRotationSpeed);
          } else if (isRotatingRight) {
            rotationVelocity = Math.max(rotationVelocity - rotationAcceleration, -maxRotationSpeed);
          }
        } else if (!isCameraReturning) {
          // ê°ì†
          if (Math.abs(rotationVelocity) > 0.0001) {
            rotationVelocity *= (1 - rotationDeceleration * 10);
            if (Math.abs(rotationVelocity) < 0.0001) {
              rotationVelocity = 0;
            }
          }
        }
        
        // íšŒì „ ì ìš©
        if (rotationVelocity !== 0) {
          cameraAngle += rotationVelocity;
          updateCameraPosition();
        }
        
        renderer.render(scene, camera);
      }
      animateThree();

      // 2D ìº”ë²„ìŠ¤ ì„¤ì •
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // ëª¨ë˜ ì»¤íŠ¼ íŒŒí‹°í´ í´ë˜ìŠ¤ (ì…ì²´ì  í™”ë©´ ì „í™˜)
      class SandCurtainParticle {
        constructor(x, y, direction, spawnDelay) {
          this.spawnDelay = spawnDelay;
          this.spawned = false;
          
          this.startX = x;
          this.startY = y;
          this.x = x;
          this.y = y;
          
          // í›¨ì”¬ ë” ë‹¤ì–‘í•œ í¬ê¸° (ì‘ì€ ì…ìë¶€í„° í° ì…ìê¹Œì§€)
          const sizeRandom = Math.random();
          this.baseSize = sizeRandom < 0.6 ? 
            Math.random() * 0.5 + 0.2 : // 60%ëŠ” ì‘ì€ ì…ì (0.2~0.7)
            Math.random() * 1.5 + 0.5;   // 40%ëŠ” í° ì…ì (0.5~2.0)
          this.size = this.baseSize;
          
          // ì§„í•œ ê°ˆìƒ‰ë¹›ì˜ ëª¨ë˜ ìƒ‰ìƒ (ì•½ê°„ ë°ê²Œ)
          const hue = 25 + Math.random() * 15; // 25~40 (ì§„í•œ ê°ˆìƒ‰)
          const saturation = 25 + Math.random() * 20; // 25~45 (ì±„ë„ ë” ë‚®ì¶¤)
          const lightness = 30 + Math.random() * 25; // 30~55 (ì¡°ê¸ˆ ë°ê²Œ)
          this.color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
          
          this.direction = direction; // 1: ì˜¤ë¥¸ìª½, -1: ì™¼ìª½
          
          // ì¢ì€ ë²”ìœ„ë¡œ ë°©ì‚¬ (í•œ ì ì—ì„œ ì§‘ì¤‘ì ìœ¼ë¡œ)
          const angleVariation = (Math.random() - 0.3) * 1.0; // -0.3~0.7 ë¼ë””ì•ˆ (ì¢ê²Œ)
          const baseSpeed = Math.random() * 20 + 15; // 15~35 (ë” ë‹¤ì–‘í•œ ì†ë„)
          this.vx = direction * baseSpeed * Math.cos(angleVariation);
          this.vy = baseSpeed * Math.sin(angleVariation);
          
          // ì¤‘ë ¥ íš¨ê³¼
          this.gravity = 0.15 + Math.random() * 0.1; // 0.15~0.25 (ê°œë³„ ì¤‘ë ¥)
          
          // ëœë¤ ìš”ì†Œ ì¶”ê°€ (ë¶ˆê·œì¹™ì„±)
          this.randomOffset = Math.random();
          this.curveStrength = (Math.random() - 0.5) * 0.5; // ê³¡ì„  ê°•ë„ ì¦ê°€
          
          // íšŒì „ íš¨ê³¼
          this.rotation = Math.random() * Math.PI * 2;
          this.rotationSpeed = (Math.random() - 0.5) * 0.2; // -0.1~0.1
          
          // íˆ¬ëª…ë„ ëœë¤ ë³€í™”
          this.baseAlpha = 0.7 + Math.random() * 0.3; // 0.7~1.0
          this.alphaFlicker = Math.random() * 0.1; // ê¹œë¹¡ì„ ê°•ë„
          
          this.z = 0;
          this.vz = 0;
          
          this.phase = 0;
          this.alpha = this.baseAlpha;
          this.createdAt = Date.now();
        }
        
        update() {
          if (!this.spawned) {
            if (Date.now() - this.createdAt > this.spawnDelay) {
              this.spawned = true;
            } else {
              return;
            }
          }
          
          const elapsed = (Date.now() - this.createdAt - this.spawnDelay) / 1000;
          
          if (this.phase === 0) {
            // Phase 0: ì£¼ë‘¥ì´ì—ì„œ í™”ë©´ ë°–ìœ¼ë¡œ (0~0.7ì´ˆ) - ê³¡ì„  ê¶¤ì  + ì¤‘ë ¥
            // ì¤‘ë ¥ ì ìš©
            this.vy += this.gravity;
            
            this.x += this.vx;
            this.y += this.vy;
            
            // ê³¡ì„  ì›€ì§ì„ ì¶”ê°€ (ë¶ˆê·œì¹™í•œ ê³¡ì„ ìœ¼ë¡œ í¼ì§)
            this.vy += Math.sin(elapsed * 8 + this.randomOffset * 20) * this.curveStrength * 5;
            this.vx += Math.cos(elapsed * 6 + this.randomOffset * 15) * this.curveStrength * 3;
            
            // íšŒì „
            this.rotation += this.rotationSpeed;
            
            // íˆ¬ëª…ë„ ê¹œë¹¡ì„ (ìì—°ìŠ¤ëŸ¬ìš´ ë³€í™”)
            this.alpha = this.baseAlpha + Math.sin(elapsed * 10 + this.randomOffset * 20) * this.alphaFlicker;
            
            // í™”ë©´ ì™„ì „íˆ ë²—ì–´ë‚  ë•Œê¹Œì§€
            const reachedEdge = this.direction > 0 ? 
              this.x > window.innerWidth + 150 : 
              this.x < -150;
            
            if (reachedEdge || elapsed > 0.7) {
              this.phase = 1;
              // y ìœ„ì¹˜ë¥¼ í™”ë©´ ì „ì²´ë¡œ ì¬ë°°ì¹˜
              this.targetY = Math.random() * window.innerHeight;
            }
          } else if (this.phase === 1) {
            // Phase 1: í™”ë©´ ë°–ì—ì„œ y ì¬ë°°ì¹˜í•˜ë©° ê°™ì€ ìª½ í™”ë©´ ëìœ¼ë¡œ (0.7~1.0ì´ˆ)
            this.y += (this.targetY - this.y) * 0.2;
            
            // ê°™ì€ ìª½ í™”ë©´ ëìœ¼ë¡œ ì´ë™
            const edgeX = this.direction > 0 ? window.innerWidth + 100 : -100;
            this.x += (edgeX - this.x) * 0.2;
            
            if (elapsed > 1.0) {
              this.phase = 2;
              this.x = edgeX;
              this.sweepStartX = this.x;
            }
          } else if (this.phase === 2) {
            // Phase 2: ê°™ì€ ìª½ì—ì„œ ë“¤ì–´ì™€ ë°˜ëŒ€í¸ìœ¼ë¡œ ì´ë™í•˜ë©° ì ì§„ì ìœ¼ë¡œ ì»¤ì§ (1.0~3ì´ˆ)
            // x ì´ë™ ê±°ë¦¬ë¡œ ì§„í–‰ë„ ê³„ì‚°
            const totalDistance = window.innerWidth + 300;
            const startX = this.sweepStartX;
            const currentDistance = Math.abs(this.x - startX);
            const sweepProgress = Math.min(1, currentDistance / totalDistance);
            
            // ì´ë™í•˜ë©´ì„œ í¬ê¸°ê°€ ì ì§„ì ìœ¼ë¡œ ì»¤ì§
            const minScale = 0.3 + this.randomOffset * 0.5; // 0.3~0.8
            const maxScale = 4.5 + this.randomOffset * 4.5; // 4.5~9.0 (1.5ë°° í™•ëŒ€)
            const scale = minScale + sweepProgress * (maxScale - minScale);
            this.size = this.baseSize * scale;
            
            // ë°˜ëŒ€í¸ìœ¼ë¡œ ë¹ ë¥´ê²Œ ì´ë™ (ì†ë„ë„ ì•½ê°„ ëœë¤)
            this.vx = -this.direction * (45 + this.randomOffset * 10);
            this.x += this.vx;
            
            // yë„ ë¶ˆê·œì¹™í•˜ê²Œ ì´ë™ + shake íš¨ê³¼
            const shakeX = Math.sin(elapsed * 15 + this.randomOffset * 30) * 2;
            const shakeY = Math.sin(elapsed * 12 + this.randomOffset * 25) * 3;
            this.x += shakeX;
            this.y += shakeY + Math.sin(elapsed * 5 + this.randomOffset * 10) * 4;
            
            // íšŒì „ ì§€ì†
            this.rotation += this.rotationSpeed * (1 + sweepProgress);
            
            // íˆ¬ëª…ë„ ë³€í™” (ê°€ê¹Œì›Œì§ˆìˆ˜ë¡ ì•½ê°„ ë” ë¶ˆíˆ¬ëª…)
            this.alpha = this.baseAlpha * (0.7 + sweepProgress * 0.3) + 
                         Math.sin(elapsed * 8 + this.randomOffset * 15) * this.alphaFlicker;
            
            // í™”ë©´ ë°˜ëŒ€í¸ ë²—ì–´ë‚˜ë©´ ì‚¬ë¼ì§
            if ((this.direction > 0 && this.x < -200) || 
                (this.direction < 0 && this.x > window.innerWidth + 200)) {
              this.phase = 3;
            }
          } else if (this.phase === 3) {
            // Phase 3: ë¹ ë¥´ê²Œ ì‚¬ë¼ì§
            this.alpha -= 0.1;
          }
        }
        
        draw(ctx) {
          if (this.alpha > 0 && this.spawned) {
            ctx.save();
            ctx.globalAlpha = Math.max(0, Math.min(1, this.alpha));
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            // ì•½ê°„ ë¶ˆê·œì¹™í•œ ëª¨ì–‘ (ì™„ë²½í•œ ì›ì´ ì•„ë‹Œ)
            ctx.fillStyle = this.color;
            ctx.beginPath();
            
            // íƒ€ì›í˜•ìœ¼ë¡œ ê·¸ë ¤ì„œ ë” ìì—°ìŠ¤ëŸ½ê²Œ
            const scaleX = 1 + Math.sin(this.randomOffset * 10) * 0.2;
            const scaleY = 1 + Math.cos(this.randomOffset * 10) * 0.2;
            ctx.scale(scaleX, scaleY);
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            ctx.fill();
            
            // ë¶€ë“œëŸ¬ìš´ ì—£ì§€ íš¨ê³¼ (ì•½ê°„ì˜ ë¸”ëŸ¬)
            if (this.size > 0.8) {
              ctx.globalAlpha = Math.max(0, Math.min(1, this.alpha)) * 0.3;
              ctx.arc(0, 0, this.size * 1.3, 0, Math.PI * 2);
              ctx.fill();
            }
            
            ctx.restore();
          }
        }
        
        isDead() {
          return this.alpha <= 0;
        }
      }

      // ì…ì(ëª¨ë˜ì•Œ) í´ë˜ìŠ¤
      class Particle {
        constructor(x, y, letterIndex) {
          // ìœ„ì¹˜ (ì²˜ìŒë¶€í„° ìµœì¢… ìœ„ì¹˜ì— ìƒì„±)
          this.x = x;
          this.y = y;
          this.originalX = x;
          this.originalY = y;
          this.letterIndex = letterIndex;
          this.size = Math.random() * 0.4 + 0.3; // 0.3~0.7 ì‚¬ì´ì˜ ë§¤ìš° ì‘ì€ ì…ì
          this.color = `hsl(45, 85%, ${Math.random() * 15 + 55}%)`; // í™©ê¸ˆë¹› í†µì¼ (ë°ê¸°ë§Œ ì•½ê°„ ë³€í™”)
          this.velocityX = 0;
          this.velocityY = 0;
          this.forming = true; // í˜•ì„± ì¤‘
          this.dispersing = false;
          this.disperseDelay = 0; // í©ì–´ì§€ê¸° ì „ ë”œë ˆì´
          this.alpha = 0; // íˆ¬ëª…í•˜ê²Œ ì‹œì‘
          this.targetAlpha = 1; // ëª©í‘œ íˆ¬ëª…ë„
          this.fadeInDelay = Math.random() * 40; // 0~40 í”„ë ˆì„ ëœë¤ ë”œë ˆì´
          this.fadeInSpeed = Math.random() * 0.02 + 0.015; // 0.015~0.035 ëœë¤ ì†ë„ (ë” ëŠë¦¬ê²Œ)
        }

        update() {
          if (this.forming) {
            // ëœë¤ ë”œë ˆì´ í›„ opacityë§Œ ì„œì„œíˆ ì¦ê°€
            if (this.fadeInDelay > 0) {
              this.fadeInDelay--;
            } else {
              this.alpha += this.fadeInSpeed;
              if (this.alpha >= this.targetAlpha) {
                this.alpha = this.targetAlpha;
                this.forming = false;
              }
            }
          } else if (this.dispersing) {
            // ë”œë ˆì´ê°€ ìˆìœ¼ë©´ ëŒ€ê¸°
            if (this.disperseDelay > 0) {
              this.disperseDelay--;
              return;
            }
            
            // ë°”ëŒì— ë‚ ì•„ê°€ëŠ” íš¨ê³¼
            this.velocityX += 0.15; // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ê°€ì†
            this.velocityY += (Math.random() - 0.5) * 0.3; // ì•½ê°„ì˜ ìƒí•˜ ì›€ì§ì„
            
            // ë°”ëŒì— í”ë“¤ë¦¼
            this.velocityY += Math.sin(Date.now() * 0.01 + this.x) * 0.1;
            
            this.x += this.velocityX;
            this.y += this.velocityY;
            this.alpha -= 0.012; // ë¹ ë¥´ê²Œ ì‚¬ë¼ì§
          }
        }

        draw() {
          if (this.alpha > 0) {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        disperse(baseX) {
          this.forming = false;
          this.dispersing = true;
          
          // ì™¼ìª½ íŒŒí‹°í´ë¶€í„° ë¨¼ì € ë‚ ì•„ê°€ë„ë¡ ë”œë ˆì´ ì„¤ì •
          // x ìœ„ì¹˜ê°€ ì™¼ìª½ì¼ìˆ˜ë¡ ë”œë ˆì´ê°€ ì§§ìŒ
          const relativeX = this.x - baseX; // ê¸€ì ê¸°ì¤€ ìƒëŒ€ ìœ„ì¹˜
          this.disperseDelay = Math.max(0, relativeX * 0.25); // ì™¼ìª½ë¶€í„° ìˆœì°¨ì ìœ¼ë¡œ (ë” ì²œì²œíˆ)
          
          // ì´ˆê¸° ì†ë„ (ì˜¤ë¥¸ìª½ + ì•½ê°„ ìœ„ë¡œ)
          this.velocityX = Math.random() * 2 + 1; // ì˜¤ë¥¸ìª½ìœ¼ë¡œ
          this.velocityY = (Math.random() - 0.7) * 2; // ì•½ê°„ ìœ„ë¡œ íŠ€ì–´ì˜¤ë¦„
        }
      }

      // ê¸€ì í´ë˜ìŠ¤
      class Letter {
        constructor(char, x, y, index) {
          this.char = char;
          this.x = x;
          this.y = y;
          this.index = index; // ê¸€ì ìƒì„± ìˆœì„œ
          this.particles = [];
          this.createdAt = Date.now();
          this.dispersed = false;
          this.width = 0; // ê¸€ì ë„ˆë¹„
          
          this.createParticles();
        }

        createParticles() {
          // ì„ì‹œ ìº”ë²„ìŠ¤ì— ê¸€ì ê·¸ë¦¬ê¸°
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          const fontSize = 80;
          tempCanvas.width = fontSize * 2;
          tempCanvas.height = fontSize * 2;

          // ì•„ë¼ë¹„ì•ˆ ë‚˜ì´íŠ¸ ëŠë‚Œì˜ ìš°ì•„í•˜ê³  íë¥´ëŠ” ë“¯í•œ í°íŠ¸
          tempCtx.font = `italic bold ${fontSize}px 'Cormorant Garamond', serif`;
          
          // ê¸€ì ë„ˆë¹„ ì¸¡ì •
          const metrics = tempCtx.measureText(this.char);
          this.width = metrics.width;
          
          tempCtx.fillStyle = 'white';
          tempCtx.textAlign = 'center';
          tempCtx.textBaseline = 'middle';
          tempCtx.fillText(this.char, fontSize, fontSize);

          // í”½ì…€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
          const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
          const pixels = imageData.data;

          // ëª¨ë˜ ì…ì ìƒì„± (í”½ì…€ ìƒ˜í”Œë§ - ë” ì´˜ì´˜í•˜ê²Œ)
          const mainParticles = [];
          for (let y = 0; y < tempCanvas.height; y += 2) {
            for (let x = 0; x < tempCanvas.width; x += 2) {
              const index = (y * tempCanvas.width + x) * 4;
              const alpha = pixels[index + 3];
              
              if (alpha > 128) { // ë¶ˆíˆ¬ëª…í•œ í”½ì…€ì—ë§Œ ì…ì ìƒì„±
                // ìœ„ì¹˜ì— ì•½ê°„ì˜ ëœë¤ ì˜¤í”„ì…‹ ì¶”ê°€ (ë” ìì—°ìŠ¤ëŸ¬ìš´ ëª¨ë˜ ëŠë‚Œ)
                const offsetX = (Math.random() - 0.5) * 2;
                const offsetY = (Math.random() - 0.5) * 2;
                const px = this.x + x - fontSize + offsetX;
                const py = this.y + y - fontSize + offsetY;
                this.particles.push(new Particle(px, py, letters.length));
                mainParticles.push({ x: px, y: py });
              }
            }
          }
          
          // ê¸€ì ì£¼ë³€ì— ì¶”ê°€ ëœë¤ íŒŒí‹°í´ ìƒì„± (ëª¨ë˜ê°€ í©ì–´ì§„ ëŠë‚Œ)
          const extraParticleCount = Math.floor(mainParticles.length * 0.2); // 20%ì˜ ì¶”ê°€ íŒŒí‹°í´
          for (let i = 0; i < extraParticleCount; i++) {
            // ê¸°ì¡´ íŒŒí‹°í´ ì¤‘ ëœë¤í•˜ê²Œ ì„ íƒ
            const baseParticle = mainParticles[Math.floor(Math.random() * mainParticles.length)];
            if (baseParticle) {
              // ì£¼ë³€ 3~10í”½ì…€ ë²”ìœ„ì— ëœë¤ ë°°ì¹˜
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * 7 + 3;
              const px = baseParticle.x + Math.cos(angle) * distance;
              const py = baseParticle.y + Math.sin(angle) * distance;
              this.particles.push(new Particle(px, py, letters.length));
            }
          }
        }

        update() {
          // wishMessageëŠ” ì‚¬ë¼ì§€ì§€ ì•ŠìŒ
          if (this.isWishMessage) {
            this.particles.forEach(p => p.update());
            return;
          }
          
          // ë§ˆì§€ë§‰ ì…ë ¥ìœ¼ë¡œë¶€í„° 0.8ì´ˆ í›„ + ì¸ë±ìŠ¤ì— ë”°ë¥¸ ìˆœì°¨ ë”œë ˆì´ (ê°€ì†)
          const timeSinceLastInput = Date.now() - lastInputTime;
          const timeSinceCreation = Date.now() - this.createdAt;
          
          // ê°„ê²©ì´ ì ì  ì¢ì•„ì§€ëŠ” ë”œë ˆì´ (ê°€ì† íš¨ê³¼, íƒ€ì´ë° ê²¹ì¹¨)
          // ì§€ìˆ˜ 0.7ì„ ì‚¬ìš©í•˜ì—¬ ê°€ì†ì„ ë” ì™„ë§Œí•˜ê²Œ, ê°„ê²©ë„ 80msë¡œ ëŠ˜ë¦¼
          const disperseDelay = 800 + (Math.pow(this.index, 0.7) * 80);
          
          // í˜•ì„±ì´ ì™„ë£Œë˜ê³ (1ì´ˆ ê²½ê³¼) + ë§ˆì§€ë§‰ ì…ë ¥ + ìˆœì°¨ ë”œë ˆì´ í›„ í©ì–´ì§
          if (!this.dispersed && timeSinceCreation > 1000 && timeSinceLastInput > disperseDelay) {
            this.dispersed = true;
            // ê¸€ìì˜ x ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ë¶€í„° ë‚ ì•„ê°€ë„ë¡
            this.particles.forEach(p => p.disperse(this.x));
          }

          this.particles.forEach(p => p.update());
        }
        
        checkShouldDisperse() {
          // í˜•ì„±ì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸
          const timeSinceCreation = Date.now() - this.createdAt;
          return timeSinceCreation > 1000;
        }

        draw() {
          this.particles.forEach(p => p.draw());
        }

        isFinished() {
          // ëª¨ë“  ì…ìê°€ ì‚¬ë¼ì¡ŒëŠ”ì§€ í™•ì¸
          return this.dispersed && this.particles.every(p => p.alpha <= 0);
        }
      }

      // ê¸€ìë“¤ì„ ì €ì¥í•˜ëŠ” ë°°ì—´
      let letters = [];
      let currentX = window.innerWidth / 2;
      let currentY = window.innerHeight / 2;
      let mouseX = window.innerWidth / 2;
      let mouseY = window.innerHeight / 2;
      let isTyping = false; // íƒ€ì´í•‘ ì¤‘ì¸ì§€ í™•ì¸
      let lastInputTime = Date.now(); // ë§ˆì§€ë§‰ ì…ë ¥ ì‹œê°„

      // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì¶”ì  (í•­ìƒ ì¶”ì )
      let lastMouseLogTime = 0;
      window.addEventListener('mousemove', function(event) {
        mouseX = event.clientX;
        mouseY = event.clientY;
        
        // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ 1ì´ˆë§ˆë‹¤ ì½˜ì†” ì¶œë ¥
        const now = Date.now();
        if (now - lastMouseLogTime > 1000) {
          console.log('Mouse Position:', { x: mouseX, y: mouseY });
          lastMouseLogTime = now;
        }
      });

      // ë§ˆìš°ìŠ¤ í´ë¦­ ì‹œ ì¹´ë©”ë¼ ìœ„ì¹˜ ì¶œë ¥
      window.addEventListener('click', function(event) {
        console.log('ğŸ“¸ Camera Position:', {
          x: camera.position.x.toFixed(2), 
          y: camera.position.y.toFixed(2), 
          z: camera.position.z.toFixed(2)
        });
      });

      // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬ (íƒ€ì´í•‘ + ì¹´ë©”ë¼ íšŒì „)
      document.addEventListener('keydown', function(event) {
        console.log('Key pressed:', event.key);

        // ì¹´ë©”ë¼ íšŒì „ (ë°©í–¥í‚¤) - ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ê³„ì† íšŒì „
        if (event.key === 'ArrowLeft') {
          isRotatingLeft = true;
          return;
        } else if (event.key === 'ArrowRight') {
          isRotatingRight = true;
          return;
        }
        
        // íƒ€ì´í•‘ ì²˜ë¦¬
        if (event.key === 'Backspace') {
          event.preventDefault();
          
          // Make your wish ì´í›„: í‚¤ì›Œë“œì˜ ë§ˆì§€ë§‰ ê¸€ì ì œê±° (í™”ë©´ì—ë„ ì ìš©)
          if (wishMessage && wishInputText.length > 0) {
            wishInputText = wishInputText.slice(0, -1);
            console.log('Wish keyword:', wishInputText);
            // í™”ë©´ì—ë„ ë°˜ì˜ë˜ë„ë¡ return ì œê±°
          }
          
          // ë§ˆì§€ë§‰ ê¸€ì ì œê±°
          if (letters.length > 0) {
            const lastLetter = letters.pop();
            const spacing = Math.min(Math.max(lastLetter.width + 8, 45), 58);
            currentX -= spacing;
            // í˜„ì¬ í…ìŠ¤íŠ¸ì—ì„œë„ ë§ˆì§€ë§‰ ê¸€ì ì œê±°
            currentTypedText = currentTypedText.slice(0, -1);
          }
          // ëª¨ë“  ê¸€ìê°€ ì§€ì›Œì§€ë©´ íƒ€ì´í•‘ ìƒíƒœ í•´ì œ
          if (letters.length === 0) {
            isTyping = false;
            currentTypedText = '';
          }
          lastInputTime = Date.now();
        } else if (event.key === 'Enter') {
          event.preventDefault();
          
          // Make your wish ì´í›„: ë°°ê²½ ë³€ê²½ (oceanë§Œ)
          if (wishMessage && wishInputText.trim() !== '') {
            const keyword = wishInputText.trim().toLowerCase();
            console.log('ğŸŒ Wish keyword:', keyword);
            
            if (keyword === 'ocean') {
              // ë°”ë‹¤ ë°°ê²½ ì´ë¯¸ì§€ (ì§ì ‘ URL ì‚¬ìš©)
              const imageUrl = 'https://images.unsplash.com/photo-1505142468610-359e7d316be0?w=1920&h=1080&fit=crop';
              
              // body ë°°ê²½ ì„¤ì •
              document.body.style.backgroundImage = `url('${imageUrl}')`;
              document.body.style.backgroundSize = 'cover';
              document.body.style.backgroundPosition = 'center';
              document.body.style.backgroundRepeat = 'no-repeat';
              document.body.style.backgroundAttachment = 'fixed';
              
              // Three.js ë°°ê²½ íˆ¬ëª…í•˜ê²Œ
              scene.background = null;
              renderer.setClearColor(0x000000, 0); // ì™„ì „ íˆ¬ëª…
              
              // ë°”ë‹¥ ì œê±°
              if (window.floorMesh) {
                scene.remove(window.floorMesh);
              }
              
              // ì•ˆê°œ ì œê±°
              scene.fog = null;
              
              console.log('âœ¨ Background changed to ocean!');
            } else {
              console.log('âš ï¸ Only "ocean" keyword is supported');
            }
            
            wishInputText = ''; // ë¦¬ì…‹
            return;
          }
          
          // "touch" í¬í•¨ ì—¬ë¶€ í™•ì¸
          console.log('Enter pressed. Current text:', currentTypedText);
          if (currentTypedText.toLowerCase().includes('touch')) {
            touchCount++;
            console.log('âœ¨ TOUCH DETECTED! Count:', touchCount);
            
            // ë¨í”„ í”ë“¤ë¦¼ ì‹œì‘
            lampShaking = true;
            lampShakeStartTime = Date.now();
            console.log('ğŸª” Lamp shaking started!');
            
            // ì„¸ ë²ˆì§¸ touchì¼ ë•Œ ì¹´ë©”ë¼ íšŒì „ ì‹œì‘ (í”ë“¤ë¦¼ê³¼ ë™ì‹œì—)
            if (touchCount === 3) {
              console.log('ğŸ“¸ Starting camera return to initial position');
              isCameraReturning = true;
              cameraReturnStartTime = Date.now();
              cameraStartAngle = cameraAngle;
              cameraTargetAngle = Math.atan2(-4.35, 1.98); // ì´ˆê¸° ê°ë„
            }
          }
          
          // ì¤„ë°”ê¿ˆ - ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ìƒˆë¡œìš´ ì¤„ ì‹œì‘
          isTyping = false;
          currentX = mouseX;
          currentY = mouseY;
          currentTypedText = ''; // í…ìŠ¤íŠ¸ ë¦¬ì…‹
          lastInputTime = Date.now();
        } else if (event.key === ' ') {
          event.preventDefault();
          
          // Make your wish ì´í›„: í‚¤ì›Œë“œì— ìŠ¤í˜ì´ìŠ¤ ì¶”ê°€ (í™”ë©´ì—ë„ í‘œì‹œ)
          if (wishMessage) {
            wishInputText += ' ';
            console.log('Wish keyword:', wishInputText);
            // ê¸€ìëŠ” í™”ë©´ì—ë„ í‘œì‹œí•˜ë„ë¡ return ì œê±°
          }
          
          // ìŠ¤í˜ì´ìŠ¤
          currentX += 25;
          currentTypedText += ' ';
          isTyping = true;
          lastInputTime = Date.now();
        } else if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
          event.preventDefault();
          
          // Make your wish ì´í›„: í‚¤ì›Œë“œ ì…ë ¥ (í™”ë©´ì—ë„ í‘œì‹œ)
          if (wishMessage) {
            wishInputText += event.key;
            console.log('Wish keyword:', wishInputText);
            // ê¸€ìëŠ” í™”ë©´ì—ë„ í‘œì‹œ
          }
          
          // íƒ€ì´í•‘ ì‹œì‘ ì‹œ í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì—ì„œ ì‹œì‘
          if (!isTyping) {
            currentX = mouseX;
            currentY = mouseY;
          }
          
          // í™”ë©´ ë„˜ì–´ê°€ë©´ í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì—ì„œ ìƒˆë¡œ ì‹œì‘
          if (currentX > canvas.width - 100) {
            currentX = mouseX;
            currentY = mouseY;
          }

          // ìƒˆ ê¸€ì ìƒì„± (ì¸ë±ìŠ¤ ì „ë‹¬)
          const letter = new Letter(event.key, currentX, currentY, letters.length);
          letters.push(letter);
          
          // í˜„ì¬ íƒ€ì´í•‘ í…ìŠ¤íŠ¸ì— ì¶”ê°€
          currentTypedText += event.key;
          
          // "touch" ë‹¨ì–´ê°€ ì™„ì„±ë˜ì—ˆëŠ”ì§€ ì‹¤ì‹œê°„ ì²´í¬
          if (currentTypedText.toLowerCase().includes('touch')) {
            console.log('"touch" detected in text:', currentTypedText);
          }
          
          // ê¸€ì ë„ˆë¹„ + ê°„ê²©(8px), ìµœì†Œ 45px, ìµœëŒ€ 58px - ë„“ì€ ê¸€ìë„ ì ì ˆí•œ ê°„ê²©
          const spacing = Math.min(Math.max(letter.width + 8, 45), 58);
          currentX += spacing;
          isTyping = true; // íƒ€ì´í•‘ ìƒíƒœë¡œ ì „í™˜
          lastInputTime = Date.now();
        }
      });

      // í‚¤ë³´ë“œ keyup ì²˜ë¦¬ (íšŒì „ ë©ˆì¶¤)
      document.addEventListener('keyup', function(event) {
        if (event.key === 'ArrowLeft') {
          isRotatingLeft = false;
        } else if (event.key === 'ArrowRight') {
          isRotatingRight = false;
        }
      });

      // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // íˆ¬ëª… ë°°ê²½

        // ì¼ë°˜ ê¸€ì ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸° (ë§¨ ì•„ë˜)
        letters.forEach(letter => {
          letter.update();
          letter.draw();
        });

        // ì‚¬ë¼ì§„ ê¸€ì ì œê±°
        letters = letters.filter(letter => !letter.isFinished());
        
        // ëª¨ë“  ê¸€ìê°€ ì‚¬ë¼ì¡Œìœ¼ë©´ íƒ€ì´í•‘ ìƒíƒœ í•´ì œ
        if (letters.length === 0) {
          isTyping = false;
        }

        // "Make your wish" ë©”ì‹œì§€ ë Œë”ë§ (ìˆœì°¨ì  ë“œëŸ¬ë‚¨ + ì¼ë ì„) - ì¤‘ê°„ ë ˆì´ì–´
        if (wishMessage && wishMessage.length > 0) {
          const timeSinceExplosion = (Date.now() - explosionStartTime) / 1000;
          
          wishMessage.forEach((msgLetter, index) => {
            // update í˜¸ì¶œ
            msgLetter.update();
            
            // íŒŒí‹°í´ ì»¤íŠ¼ì´ ì§€ë‚˜ê°„ í›„ ìˆœì°¨ì ìœ¼ë¡œ ë“œëŸ¬ë‚¨ (ì˜¤ë¥¸ìª½â†’ì™¼ìª½)
            const revealStartTime = 2.0; // ì»¤íŠ¼ì´ í™”ë©´ ë“¤ì–´ì˜¬ ë•Œë¶€í„°
            const timeSinceRevealStart = timeSinceExplosion - revealStartTime;
            
            if (timeSinceRevealStart > msgLetter.revealDelay) {
              // ë“œëŸ¬ë‚˜ê¸° ì‹œì‘
              if (!msgLetter.revealed) {
                msgLetter.revealed = true;
              }
              
              // íŒŒí‹°í´ ì•ŒíŒŒ ì¦ê°€ (í˜ì´ë“œì¸)
              msgLetter.particles.forEach(p => {
                if (p.alpha < p.targetAlpha) {
                  p.alpha += 0.03; // ë¹ ë¥´ê²Œ ë‚˜íƒ€ë‚¨
                }
              });
            }
            
            // ì¼ë ì´ëŠ” íš¨ê³¼ (ë“œëŸ¬ë‚œ ê¸€ìë§Œ)
            if (msgLetter.revealed) {
              const waveOffset = Math.sin(Date.now() * 0.002 + index * 0.3) * 5;
              
              msgLetter.particles.forEach(p => {
                p.y = p.originalY + waveOffset;
              });
            }
            
            msgLetter.draw();
          });
        }

        // ëª¨ë˜ ì»¤íŠ¼ ì• ë‹ˆë©”ì´ì…˜ (í™”ë©´ ì „í™˜ íš¨ê³¼) - ë§¨ ìœ„ ë ˆì´ì–´
        if (isExploding || explosionParticles.length > 0) {
          const explosionElapsed = (Date.now() - explosionStartTime) / 1000;
          
          // ì£¼ë‘¥ì´ì—ì„œ ê³„ì† íŒŒí‹°í´ ìƒì„± (ì²˜ìŒ 1.5ì´ˆ ë™ì•ˆ - ë” ê¸¸ê²Œ)
          if (explosionElapsed < 1.5) {
            // ê³ ì •ëœ í™”ë©´ ì¢Œí‘œ ì‚¬ìš© (ì£¼ë‘¥ì´ ë ìœ„ì¹˜)
            const spoutX = 469;
            const spoutY = 325; // ì•„ì£¼ ì‚´ì§ ìœ„ë¡œ (329 â†’ 325)
            
            // ì™¼ìª½ìœ¼ë¡œ ë‚˜ê°€ë„ë¡ ê³ ì • (ì£¼ë‘¥ì´ê°€ ì™¼ìª½ì„ í–¥í•¨)
            const direction = -1;
            
            // ë§¤ í”„ë ˆì„ë§ˆë‹¤ íŒŒí‹°í´ ìƒì„± (2ë°°ë¡œ!)
            for (let i = 0; i < 200; i++) {
              // ì£¼ë‘¥ì´ ì…êµ¬ì—ì„œ ì‹œì‘ (ì™„ì „íˆ í•œ ì ì—ì„œ)
              const offsetX = 0;
              const offsetY = 0;
              const startX = spoutX + offsetX;
              const startY = spoutY + offsetY;
              
              // ë§¤ìš° ì§§ì€ ë”œë ˆì´ë¡œ ë¾°ì¡±í•˜ê²Œ (ì‚¼ê°í˜• ëì²˜ëŸ¼)
              const spawnDelay = Math.random() * 600; // 0~50ms (ë§¤ìš° ì§§ê²Œ)
              
              explosionParticles.push(new SandCurtainParticle(startX, startY, direction, spawnDelay));
            }
          }
          
          // íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
          explosionParticles.forEach(p => {
            p.update();
            p.draw(ctx);
          });
          
          // ì£½ì€ íŒŒí‹°í´ ì œê±°
          explosionParticles = explosionParticles.filter(p => !p.isDead());
          
          // 0.3ì´ˆ í›„ "Make your wish" ë©”ì‹œì§€ ìƒì„± (ìˆ¨ê²¨ì§„ ìƒíƒœë¡œ)
          if (explosionElapsed > 0.3 && !wishMessage) {
            console.log('ğŸŒŸ Creating "Make your wish" message (hidden)!');
            
            const msgX = window.innerWidth / 2 - 250;
            const msgY = window.innerHeight * 0.65; // ë¨í”„ ì•„ë˜ìª½ìœ¼ë¡œ
            
            wishMessage = [];
            const message = "Make your wish";
            let msgCurrentX = msgX;
            
            // ë¨¼ì € ëª¨ë“  ê¸€ì ìƒì„±
            for (let i = 0; i < message.length; i++) {
              const char = message[i];
              const msgLetter = new Letter(char, msgCurrentX, msgY, i);
              msgLetter.isWishMessage = true;
              msgLetter.revealDelay = 0; // ë‚˜ì¤‘ì— ì„¤ì •
              msgLetter.revealed = false; // ì•„ì§ ë“œëŸ¬ë‚˜ì§€ ì•ŠìŒ
              
              // ëª¨ë“  íŒŒí‹°í´ì„ íˆ¬ëª…í•˜ê²Œ ì‹œì‘
              msgLetter.particles.forEach(p => {
                p.alpha = 0;
                p.targetAlpha = 1;
                p.forming = false; // í˜•ì„± ì¤‘ì´ ì•„ë‹˜
              });
              
              wishMessage.push(msgLetter);
              const spacing = char === ' ' ? 25 : Math.min(Math.max(msgLetter.width + 8, 45), 58);
              msgCurrentX += spacing;
            }
            
            // ì˜¤ë¥¸ìª½ë¶€í„° ë“œëŸ¬ë‚˜ë„ë¡ ë”œë ˆì´ ì„¤ì • (íŒŒí‹°í´ ì»¤íŠ¼ ì†ë„ì— ë§ì¶¤)
            const totalWidth = msgCurrentX - msgX;
            // íŒŒí‹°í´ì´ í™”ë©´ì„ ê°€ë¡œì§€ë¥´ëŠ” ì‹œê°„ ê³„ì‚° (í™”ë©´ë„ˆë¹„ / ì†ë„)
            const curtainSweepDuration = window.innerWidth / 50 / 60; // ì•½ 0.3~0.5ì´ˆ
            
            wishMessage.forEach((msgLetter) => {
              const letterX = msgLetter.x;
              // ì˜¤ë¥¸ìª½ ê¸€ìì¼ìˆ˜ë¡ ë¨¼ì € ë“œëŸ¬ë‚¨ (ì—­ìˆœ)
              const relativeX = letterX - msgX;
              const normalizedX = relativeX / totalWidth; // 0(ì™¼ìª½)~1(ì˜¤ë¥¸ìª½)
              // íŒŒí‹°í´ ì»¤íŠ¼ì´ ê° ê¸€ì ìœ„ì¹˜ì— ë„ë‹¬í•˜ëŠ” ì‹œê°„
              msgLetter.revealDelay = (1 - normalizedX) * 0.8; // 0~0.8ì´ˆ (ë” ë¹ ë¥´ê²Œ)
            });
            
            console.log('âœ¨ wishMessage created (will reveal right to left)!');
          }
          
          // ëª¨ë“  íŒŒí‹°í´ì´ ì‚¬ë¼ì§€ë©´ ì¢…ë£Œ
          if (explosionElapsed > 4 && explosionParticles.length === 0) {
            isExploding = false;
            console.log('ğŸ¬ Sand curtain ended - message revealed!');
          }
        }

        // íƒ€ì´í•‘ ì¤‘ì´ ì•„ë‹ˆë©´ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ë”°ë¼ê°
        if (!isTyping) {
          currentX = mouseX;
          currentY = mouseY;
        }

        requestAnimationFrame(animate);
      }

      animate();

      // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
      window.addEventListener('resize', () => {
        // Three.js ë¦¬ì‚¬ì´ì¦ˆ
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // 2D ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
    </script>
  </body>
</html>
