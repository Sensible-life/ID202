<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="input-mode" content="latin">
    <meta http-equiv="Content-Language" content="en">
    <title>Sand Letters</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@1,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/loading.css">
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="keywords.js"></script>
    <script src="loading.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: monospace;
        /* ì˜ì–´ ì…ë ¥ ëª¨ë“œ ìœ ë„ */
        ime-mode: disabled;
        -ms-ime-mode: disabled;
      }
      #three-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        pointer-events: none; /* ë§ˆìš°ìŠ¤ ì…ë ¥ ì°¨ë‹¨ */
      }
      #canvas {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 2;
        cursor: text;
        pointer-events: none; /* ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ëŠ” windowì—ì„œ ë°›ìŒ */
      }
    </style>
  </head>
  <body lang="en">
    <div id="three-container"></div>
    <canvas id="canvas"></canvas>

    <script>
      // í˜ì´ì§€ ë¡œë“œ ì‹œ IME(í•œê¸€ ì…ë ¥) ë¹„í™œì„±í™” ìœ ë„
      document.addEventListener('DOMContentLoaded', function() {
        document.body.setAttribute('lang', 'en');
        // í˜ì´ì§€ í¬ì»¤ìŠ¤ ì‹œ ì˜ì–´ ì…ë ¥ ëª¨ë“œ ìœ ë„
        window.focus();
      });
      
      // í‚¤ ì…ë ¥ ì‹œì‘ ì‹œ ì˜ì–´ ì…ë ¥ ìœ ë„
      let isFirstInput = true;
      document.addEventListener('keydown', function(e) {
        if (isFirstInput && e.key.length === 1) {
          isFirstInput = false;
          console.log('âœï¸ English input mode recommended');
        }
      }, { once: false });
    </script>
    
    <script>
      // Three.js 3D ì”¬ ì„¤ì •
      const scene = new THREE.Scene();
      const floorColor = 0x1a1a1a; // ì•½ê°„ ë°ì€ ê²€ì€ìƒ‰
      scene.background = new THREE.Color(floorColor); // ë°°ê²½ê³¼ ë°”ë‹¥ ìƒ‰ìƒ í†µì¼
      scene.fog = new THREE.Fog(floorColor, 20, 100); // ì•ˆê°œ íš¨ê³¼ë¡œ ë¬´í•œ ëŠë‚Œ
      
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // ë°°ê²½ íˆ¬ëª… ê°€ëŠ¥í•˜ë„ë¡
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('three-container').appendChild(renderer.domElement);

      // ë¬´í•œ í™•ì¥ë˜ëŠ” ë°”ë‹¥ (ë§¤ìš° í¬ê²Œ)
      const roomSize = 200;
      const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
      const floorMaterial = new THREE.MeshStandardMaterial({ 
        color: floorColor,
        roughness: 0.9,
        metalness: 0.1
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -5;
      floor.receiveShadow = true;
      scene.add(floor);
      window.floorMesh = floor; // ë‚˜ì¤‘ì— ì œê±°í•  ìˆ˜ ìˆë„ë¡ ì €ì¥

      // GLB ë¨í”„ ëª¨ë¸ ë¡œë“œ
      const lampGroup = new THREE.Group();
      lampGroup.position.set(0, -5.0, 0); // ë°”ë‹¥ì— ë” ê°€ê¹Œì´
      scene.add(lampGroup);
      
      // GLTFLoaderë¡œ GLB íŒŒì¼ ë¡œë“œ
      const loader = new THREE.GLTFLoader();
      loader.load('alladins_lamp.glb', 
        function(gltf) {
          console.log('âœ¨ Lamp model loaded!');
          const lampModel = gltf.scene;
          
          // í¬ê¸° ì¡°ì • (ì ë‹¹í•œ í¬ê¸°)
          lampModel.scale.set(12.0,   12.0, 12.0);
          
          // íšŒì „ (180ë„)
          lampModel.rotation.y = Math.PI;
          
          // ê·¸ë¦¼ì ì„¤ì •
          lampModel.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          
          lampGroup.add(lampModel);
        },
        function(xhr) {
          console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        },
        function(error) {
          console.error('âŒ Error loading lamp model:', error);
        }
      );

      // ì¡°ëª… ì„¤ì • (ë°ê²Œ)
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); // 0.5 â†’ 1.2
      scene.add(ambientLight);

      // ë¨í”„ì—ì„œ ë‚˜ì˜¤ëŠ” ë°ì€ ë¹›
      const lampLight = new THREE.PointLight(0xffffff, 8, 60); // 4 â†’ 8
      lampLight.position.set(0, -4.5, 0); // ë¨í”„ ìœ„ì¹˜ì— ë§ì¶¤
      scene.add(lampLight);

      // ë©”ì¸ ì¡°ëª… (ì™¼ìª½ìœ¼ë¡œ 60ë„ íšŒì „, ë‚®ì€ ê°ë„)
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.5); // 0.9 â†’ 1.5
      mainLight.position.set(-3.3, 1.5, -6.7); // ì™¼ìª½ 60ë„, ë‚®ì€ ìœ„ì¹˜
      mainLight.target.position.set(0, -5, 0); // ë¨í”„ë¥¼ í–¥í•¨
      scene.add(mainLight.target);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 2048;
      mainLight.shadow.mapSize.height = 2048;
      mainLight.shadow.camera.left = -10;
      mainLight.shadow.camera.right = 10;
      mainLight.shadow.camera.top = 10;
      mainLight.shadow.camera.bottom = -10;
      mainLight.shadow.camera.near = 0.5;
      mainLight.shadow.camera.far = 20;
      scene.add(mainLight);

      // ì¹´ë©”ë¼ ì´ˆê¸° ìœ„ì¹˜ ì„¤ì •
      camera.position.set(1.98, -0.12, -4.35);
      camera.lookAt(0, -5, 0); // ë¨í”„ë¥¼ ë°”ë¼ë´„
      camera.fov = 95;
      camera.updateProjectionMatrix();
      
      // í‚¤ë³´ë“œ íšŒì „ìš© ë³€ìˆ˜ (OrbitControlsì™€ ë³„ë„)
      let cameraDistance = Math.sqrt(1.98*1.98 + 4.35*4.35);
      let cameraAngle = Math.atan2(-4.35, 1.98);
      let cameraHeight = -0.12;
      
      function updateCameraPosition() {
        camera.position.x = Math.cos(cameraAngle) * cameraDistance;
        camera.position.y = cameraHeight;
        camera.position.z = Math.sin(cameraAngle) * cameraDistance;
        camera.lookAt(0, -5, 0); // ë¨í”„ë¥¼ ë°”ë¼ë´„
      }
      
      
      // í‚¤ë³´ë“œ íšŒì „ì„ ìœ„í•œ ë³€ìˆ˜
      let isRotatingLeft = false;
      let isRotatingRight = false;
      let rotationVelocity = 0;
      const maxRotationSpeed = 0.03;
      const rotationAcceleration = 0.002;
      const rotationDeceleration = 0.001;
      
      // ì¹´ë©”ë¼ ì´ˆê¸° ìœ„ì¹˜ë¡œ ë³µê·€ (touch 3ë²ˆ ì‹œ)
      let isCameraReturning = false;
      let cameraReturnStartTime = 0;
      let cameraStartAngle = 0;
      let cameraTargetAngle = 0;
      
      // touch ì¹´ìš´í„° ë° ë¨í”„ ì• ë‹ˆë©”ì´ì…˜ ë³€ìˆ˜
      let touchCount = 0;
      let lampShaking = false;
      let lampShakeStartTime = 0;
      let currentTypedText = '';
      let introMessage = null; // ì¤‘ê°„ ë¬¸ì¥ ("Wish for a new world..." 3ë¶€ë¶„)
      let wishMessage = null;
      let wishInputText = ''; // Make your wish ì´í›„ ì…ë ¥ë˜ëŠ” í‚¤ì›Œë“œ
      let explosionParticles = []; // ì£¼ë‘¥ì´ì—ì„œ í­ë°œí•˜ëŠ” íŒŒí‹°í´
      let isExploding = false;
      let explosionStartTime = 0;
      let koreanWarningMessage = null; // í•œê¸€ ê²½ê³  ë©”ì‹œì§€
      let koreanWarningStartTime = 0;
      let completedSentences = 0; // ì™„ì„±ëœ ë¬¸ì¥ ìˆ˜ (touch ì—†ì´)
      let touchHintMessage = null; // touch íŒíŠ¸ ë©”ì‹œì§€
      let touchHintStartTime = 0;
      let touchInteractionsEnabled = true; // touch ìƒí˜¸ì‘ìš© í™œì„±í™” ì—¬ë¶€
      let clickHintMessage = null; // í´ë¦­ íŒíŠ¸ ë©”ì‹œì§€
      let clickHintStartTime = 0;
      let touchHintShown = false; // touch íŒíŠ¸ê°€ ì´ë¯¸ í‘œì‹œë˜ì—ˆëŠ”ì§€ ì¶”ì 
      let clickHintShown = false; // í´ë¦­ íŒíŠ¸ê°€ ì´ë¯¸ í‘œì‹œë˜ì—ˆëŠ”ì§€ ì¶”ì 
      let koreanHintShown = false; // í•œê¸€ íŒíŠ¸ê°€ ì´ë¯¸ í‘œì‹œë˜ì—ˆëŠ”ì§€ ì¶”ì 
      let enterHintMessage = null; // Enter í‚¤ íŒíŠ¸ ë©”ì‹œì§€
      let enterHintStartTime = 0;
      let enterHintShown = false; // Enter íŒíŠ¸ê°€ ì´ë¯¸ í‘œì‹œë˜ì—ˆëŠ”ì§€ ì¶”ì 
      let sentencesWithoutEnter = 0; // ì—”í„° ì—†ì´ ì‚¬ë¼ì§„ ë¬¸ì¥ ìˆ˜

      // Three.js ì• ë‹ˆë©”ì´ì…˜
      function animateThree() {
        requestAnimationFrame(animateThree);
        
        // ë¨í”„ ë¶ˆë¹›ì´ ì•„ì£¼ ì€ì€í•˜ê²Œ ê¹œë°•ì„
        lampLight.intensity = 2.5 + Math.sin(Date.now() * 0.0008) * 0.3;
        
        // ë¨í”„ í”ë“¤ë¦¼ ì• ë‹ˆë©”ì´ì…˜ (touch íšŸìˆ˜ì— ë”°ë¼ ì ì§„ì ìœ¼ë¡œ ê°•í•´ì§)
        if (lampShaking) {
          const elapsed = (Date.now() - lampShakeStartTime) / 1000; // ì´ˆ ë‹¨ìœ„
          
          // touch íšŸìˆ˜ì— ë”°ë¥¸ ê°•ë„ì™€ ì§€ì† ì‹œê°„ (1->2->3)
          const intensityMultiplier = touchCount * 0.4; // 0.4, 0.8, 1.2 (ì²«ë²ˆì§¸ ë” ì•½í•˜ê²Œ)
          const duration = touchCount === 1 ? 1.5 : (touchCount === 2 ? 2.5 : 4); // 1.5ì´ˆ, 2.5ì´ˆ, 4ì´ˆ
          
          if (elapsed < duration) {
            const t = elapsed / duration; // 0~1
            
            // ease-in-out í•¨ìˆ˜ë¡œ ë¶€ë“œëŸ¬ìš´ ì‹œì‘ê³¼ ë
            const easeInOut = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            const shake = (1 - easeInOut); // ì ì  ì•½í•´ì§ (ë¶€ë“œëŸ½ê²Œ)
            
            // ì‹œì‘ ë¶€ë¶„ ease-in (ì²˜ìŒ 0.2ì´ˆ ë™ì•ˆ ì ì§„ì ìœ¼ë¡œ ê°•í•´ì§)
            const easeInFactor = elapsed < 0.2 ? (elapsed / 0.2) * (elapsed / 0.2) : 1; // quadratic ease-in
            
            const finalShake = shake * easeInFactor;
            
            lampGroup.rotation.x = Math.sin(Date.now() * 0.008) * finalShake * 0.3 * intensityMultiplier;
            lampGroup.rotation.y = Math.sin(Date.now() * 0.011) * finalShake * 0.4 * intensityMultiplier;
            lampGroup.rotation.z = Math.sin(Date.now() * 0.009) * finalShake * 0.25 * intensityMultiplier;
          } else {
            // ì›ìœ„ì¹˜ë¡œ ë¶€ë“œëŸ½ê²Œ ë³µê·€
            lampGroup.rotation.x *= 0.85;
            lampGroup.rotation.y *= 0.85;
            lampGroup.rotation.z *= 0.85;
            
            if (Math.abs(lampGroup.rotation.x) < 0.01 && 
                Math.abs(lampGroup.rotation.y) < 0.01 && 
                Math.abs(lampGroup.rotation.z) < 0.01) {
              lampGroup.rotation.set(0, 0, 0);
              lampShaking = false;
              console.log('Lamp stopped shaking');
              
              // ì„¸ ë²ˆì§¸ touchì¼ ë•Œë§Œ ëª¨ë˜ë°”ëŒ ì‹œì‘
              if (touchCount === 3) {
                console.log('ğŸŒªï¸ Starting sand storm!');
                isExploding = true;
                explosionStartTime = Date.now();
                // í™”ë©´ ì „í™˜ ì‹œì‘ìœ¼ë¡œ touch ìƒí˜¸ì‘ìš© ë¹„í™œì„±í™”
                touchInteractionsEnabled = false;
                console.log('ğŸš« Touch interactions disabled due to screen transition');
                
                // ë‚¨ì•„ìˆëŠ” touch íŒíŠ¸ ë©”ì‹œì§€ë„ í•¨ê»˜ ë‚ ë¦¬ê¸°
                if (touchHintMessage) {
                  console.log('ğŸŒªï¸ Dispersing remaining touch hint during screen transition');
                  disperseTouchHint();
                }
              }
            }
          }
        }
        
        // ì¹´ë©”ë¼ ì´ˆê¸° ìœ„ì¹˜ë¡œ ë³µê·€ (touch 3ë²ˆ ì‹œ)
        if (isCameraReturning) {
          const returnDuration = 2.0; // 2ì´ˆì— ê±¸ì³ ë³µê·€
          const returnElapsed = (Date.now() - cameraReturnStartTime) / 1000;
          const returnProgress = Math.min(returnElapsed / returnDuration, 1.0);
          
          // ease-in-out í•¨ìˆ˜
          const easeInOut = returnProgress < 0.5 
            ? 2 * returnProgress * returnProgress 
            : 1 - Math.pow(-2 * returnProgress + 2, 2) / 2;
          
          // ê°ë„ ì°¨ì´ ê³„ì‚° (ìµœë‹¨ ê²½ë¡œë¡œ íšŒì „)
          let angleDiff = cameraTargetAngle - cameraStartAngle;
          // -PI ~ PI ë²”ìœ„ë¡œ ì •ê·œí™”
          while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
          while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
          
          cameraAngle = cameraStartAngle + angleDiff * easeInOut;
          updateCameraPosition();
          
          if (returnProgress >= 1.0) {
            isCameraReturning = false;
            console.log('ğŸ“¸ Camera returned to initial position');
          }
        }
        
        // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ íšŒì „ (ease in/out) - í‚¤ë³´ë“œ
        if (!isCameraReturning && (isRotatingLeft || isRotatingRight)) {
          // ê°€ì†
          if (isRotatingLeft) {
            rotationVelocity = Math.min(rotationVelocity + rotationAcceleration, maxRotationSpeed);
          } else if (isRotatingRight) {
            rotationVelocity = Math.max(rotationVelocity - rotationAcceleration, -maxRotationSpeed);
          }
        } else if (!isCameraReturning) {
          // ê°ì†
          if (Math.abs(rotationVelocity) > 0.0001) {
            rotationVelocity *= (1 - rotationDeceleration * 10);
            if (Math.abs(rotationVelocity) < 0.0001) {
              rotationVelocity = 0;
            }
          }
        }
        
        // íšŒì „ ì ìš©
        if (rotationVelocity !== 0) {
          cameraAngle += rotationVelocity;
          updateCameraPosition();
        }
        
        renderer.render(scene, camera);
      }
      animateThree();

      // 2D ìº”ë²„ìŠ¤ ì„¤ì •
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // ë°°ê²½ ì´ë¯¸ì§€ ìƒ˜í”Œë§ìš© ìˆ¨ê²¨ì§„ ìº”ë²„ìŠ¤
      const bgCanvas = document.createElement('canvas');
      const bgCtx = bgCanvas.getContext('2d', { willReadFrequently: true });
      bgCanvas.width = window.innerWidth;
      bgCanvas.height = window.innerHeight;
      let bgImageData = null;
      let currentBackgroundImage = null;
      
      // ë°°ê²½ìƒ‰ì—ì„œ ëŒ€ë¹„ë˜ëŠ” ìƒ‰ìƒ ê³„ì‚° í•¨ìˆ˜
      function getContrastColor(r, g, b) {
        // ëª…ë„ ê³„ì‚° (0~255)
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        
        // ë°ì€ ë°°ê²½ì´ë©´ ì–´ë‘ìš´ ìƒ‰, ì–´ë‘ìš´ ë°°ê²½ì´ë©´ ë°ì€ ìƒ‰
        if (brightness > 128) {
          // ë°ì€ ë°°ê²½ -> ì–´ë‘ìš´ ê¸ˆìƒ‰/ê°ˆìƒ‰
          return `rgba(139, 90, 43, ${0.8 + Math.random() * 0.2})`;
        } else {
          // ì–´ë‘ìš´ ë°°ê²½ -> ë°ì€ ê¸ˆìƒ‰
          return `rgba(255, 215, 100, ${0.8 + Math.random() * 0.2})`;
        }
      }
      
      // ë°°ê²½ ì´ë¯¸ì§€ ë°ê¸° ë¶„ì„ ë° ë¨í”„ ì¡°ëª… ì¡°ì • í•¨ìˆ˜
      function adjustLampLightingBasedOnBackground(imageData) {
        const data = imageData.data;
        let totalBrightness = 0;
        let sampleCount = 0;
        
        // ì´ë¯¸ì§€ ì¤‘ì•™ ì˜ì—­ì˜ ë°ê¸°ë¥¼ ìƒ˜í”Œë§ (ë¨í”„ê°€ ìœ„ì¹˜í•œ ë¶€ë¶„)
        const centerX = Math.floor(imageData.width / 2);
        const centerY = Math.floor(imageData.height / 2);
        const sampleRadius = Math.min(imageData.width, imageData.height) / 6; // ì¤‘ì•™ 1/3 ì˜ì—­
        
        for (let y = centerY - sampleRadius; y < centerY + sampleRadius; y += 10) {
          for (let x = centerX - sampleRadius; x < centerX + sampleRadius; x += 10) {
            if (x >= 0 && x < imageData.width && y >= 0 && y < imageData.height) {
              const index = (y * imageData.width + x) * 4;
              const r = data[index];
              const g = data[index + 1];
              const b = data[index + 2];
              
              // ëª…ë„ ê³„ì‚° (0~255)
              const brightness = (r * 299 + g * 587 + b * 114) / 1000;
              totalBrightness += brightness;
              sampleCount++;
            }
          }
        }
        
        const averageBrightness = totalBrightness / sampleCount;
        const normalizedBrightness = averageBrightness / 255; // 0~1
        
        console.log(`ğŸ“Š Background brightness: ${averageBrightness.toFixed(1)} (normalized: ${normalizedBrightness.toFixed(2)})`);
        
        // ì–´ë‘ìš´ ë°°ê²½ì¼ìˆ˜ë¡ ì¡°ëª…ì„ ë°ê²Œ (0.3~1.0 ë²”ìœ„ì—ì„œ 1.5~4.0ìœ¼ë¡œ ë§¤í•‘)
        const lightIntensity = Math.max(1.5, (1 - normalizedBrightness) * 2.5 + 1.5);
        
        // ì•°ë¹„ì–¸íŠ¸ ë¼ì´íŠ¸ ì¡°ì •
        ambientLight.intensity = Math.max(0.8, (1 - normalizedBrightness) * 1.0 + 0.8);
        
        // ë¨í”„ ë¼ì´íŠ¸ ì¡°ì •
        lampLight.intensity = Math.max(6, lightIntensity * 8);
        
        // ë©”ì¸ ë¼ì´íŠ¸ ì¡°ì •
        mainLight.intensity = Math.max(1.0, lightIntensity * 1.2);
        
        console.log(`ğŸ’¡ Adjusted lighting - Ambient: ${ambientLight.intensity.toFixed(2)}, Lamp: ${lampLight.intensity.toFixed(2)}, Main: ${mainLight.intensity.toFixed(2)}`);
      }
      
      // íŒŒí‹°í´ ìœ„ì¹˜ì˜ ë°°ê²½ìƒ‰ ê°€ì ¸ì˜¤ê¸°
      function getBackgroundColorAt(x, y) {
        if (!bgImageData) {
          // ë°°ê²½ ì´ë¯¸ì§€ ì—†ìœ¼ë©´ ê¸°ë³¸ ê¸ˆìƒ‰
          return `hsl(45, 85%, ${Math.random() * 15 + 55}%)`;
        }
        
        const px = Math.floor(x);
        const py = Math.floor(y);
        
        if (px < 0 || px >= bgCanvas.width || py < 0 || py >= bgCanvas.height) {
          return `hsl(45, 85%, ${Math.random() * 15 + 55}%)`;
        }
        
        const index = (py * bgCanvas.width + px) * 4;
        const r = bgImageData.data[index];
        const g = bgImageData.data[index + 1];
        const b = bgImageData.data[index + 2];
        
        return getContrastColor(r, g, b);
      }

      // ëª¨ë˜ ì»¤íŠ¼ íŒŒí‹°í´ í´ë˜ìŠ¤ (ì…ì²´ì  í™”ë©´ ì „í™˜)
      class SandCurtainParticle {
        constructor(x, y, direction, spawnDelay) {
          this.spawnDelay = spawnDelay;
          this.spawned = false;
          
          this.startX = x;
          this.startY = y;
          this.x = x;
          this.y = y;
          
          // í›¨ì”¬ ë” ë‹¤ì–‘í•œ í¬ê¸° (ì‘ì€ ì…ìë¶€í„° í° ì…ìê¹Œì§€)
          const sizeRandom = Math.random();
          this.baseSize = sizeRandom < 0.6 ? 
            Math.random() * 0.5 + 0.2 : // 60%ëŠ” ì‘ì€ ì…ì (0.2~0.7)
            Math.random() * 1.5 + 0.5;   // 40%ëŠ” í° ì…ì (0.5~2.0)
          this.size = this.baseSize;
          
          // ì§„í•œ ê°ˆìƒ‰ë¹›ì˜ ëª¨ë˜ ìƒ‰ìƒ (ì•½ê°„ ë°ê²Œ)
          const hue = 25 + Math.random() * 15; // 25~40 (ì§„í•œ ê°ˆìƒ‰)
          const saturation = 25 + Math.random() * 20; // 25~45 (ì±„ë„ ë” ë‚®ì¶¤)
          const lightness = 30 + Math.random() * 25; // 30~55 (ì¡°ê¸ˆ ë°ê²Œ)
          this.color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
          
          this.direction = direction; // 1: ì˜¤ë¥¸ìª½, -1: ì™¼ìª½
          
          // ì¢ì€ ë²”ìœ„ë¡œ ë°©ì‚¬ (í•œ ì ì—ì„œ ì§‘ì¤‘ì ìœ¼ë¡œ)
          const angleVariation = (Math.random() - 0.3) * 1.0; // -0.3~0.7 ë¼ë””ì•ˆ (ì¢ê²Œ)
          const baseSpeed = Math.random() * 20 + 15; // 15~35 (ë” ë‹¤ì–‘í•œ ì†ë„)
          this.vx = direction * baseSpeed * Math.cos(angleVariation);
          this.vy = baseSpeed * Math.sin(angleVariation);
          
          // ì¤‘ë ¥ íš¨ê³¼
          this.gravity = 0.15 + Math.random() * 0.1; // 0.15~0.25 (ê°œë³„ ì¤‘ë ¥)
          
          // ëœë¤ ìš”ì†Œ ì¶”ê°€ (ë¶ˆê·œì¹™ì„±)
          this.randomOffset = Math.random();
          this.curveStrength = (Math.random() - 0.5) * 0.5; // ê³¡ì„  ê°•ë„ ì¦ê°€
          
          // íšŒì „ íš¨ê³¼
          this.rotation = Math.random() * Math.PI * 2;
          this.rotationSpeed = (Math.random() - 0.5) * 0.2; // -0.1~0.1
          
          // íˆ¬ëª…ë„ ëœë¤ ë³€í™”
          this.baseAlpha = 0.7 + Math.random() * 0.3; // 0.7~1.0
          this.alphaFlicker = Math.random() * 0.1; // ê¹œë¹¡ì„ ê°•ë„
          
          this.z = 0;
          this.vz = 0;
          
          this.phase = 0;
          this.alpha = this.baseAlpha;
          this.createdAt = Date.now();
        }
        
        update() {
          if (!this.spawned) {
            if (Date.now() - this.createdAt > this.spawnDelay) {
              this.spawned = true;
            } else {
              return;
            }
          }
          
          const elapsed = (Date.now() - this.createdAt - this.spawnDelay) / 1000;
          
          if (this.phase === 0) {
            // Phase 0: ì£¼ë‘¥ì´ì—ì„œ í™”ë©´ ë°–ìœ¼ë¡œ (0~0.7ì´ˆ) - ê³¡ì„  ê¶¤ì  + ì¤‘ë ¥
            // ì¤‘ë ¥ ì ìš©
            this.vy += this.gravity;
            
            this.x += this.vx;
            this.y += this.vy;
            
            // ê³¡ì„  ì›€ì§ì„ ì¶”ê°€ (ë¶ˆê·œì¹™í•œ ê³¡ì„ ìœ¼ë¡œ í¼ì§)
            this.vy += Math.sin(elapsed * 8 + this.randomOffset * 20) * this.curveStrength * 5;
            this.vx += Math.cos(elapsed * 6 + this.randomOffset * 15) * this.curveStrength * 3;
            
            // íšŒì „
            this.rotation += this.rotationSpeed;
            
            // íˆ¬ëª…ë„ ê¹œë¹¡ì„ (ìì—°ìŠ¤ëŸ¬ìš´ ë³€í™”)
            this.alpha = this.baseAlpha + Math.sin(elapsed * 10 + this.randomOffset * 20) * this.alphaFlicker;
            
            // í™”ë©´ ì™„ì „íˆ ë²—ì–´ë‚  ë•Œê¹Œì§€
            const reachedEdge = this.direction > 0 ? 
              this.x > window.innerWidth + 150 : 
              this.x < -150;
            
            if (reachedEdge || elapsed > 0.7) {
              this.phase = 1;
              // y ìœ„ì¹˜ë¥¼ í™”ë©´ ì „ì²´ë¡œ ì¬ë°°ì¹˜
              this.targetY = Math.random() * window.innerHeight;
            }
          } else if (this.phase === 1) {
            // Phase 1: í™”ë©´ ë°–ì—ì„œ y ì¬ë°°ì¹˜í•˜ë©° ê°™ì€ ìª½ í™”ë©´ ëìœ¼ë¡œ (0.7~1.0ì´ˆ)
            this.y += (this.targetY - this.y) * 0.2;
            
            // ê°™ì€ ìª½ í™”ë©´ ëìœ¼ë¡œ ì´ë™
            const edgeX = this.direction > 0 ? window.innerWidth + 100 : -100;
            this.x += (edgeX - this.x) * 0.2;
            
            if (elapsed > 1.0) {
              this.phase = 2;
              this.x = edgeX;
              this.sweepStartX = this.x;
            }
          } else if (this.phase === 2) {
            // Phase 2: ê°™ì€ ìª½ì—ì„œ ë“¤ì–´ì™€ ë°˜ëŒ€í¸ìœ¼ë¡œ ì´ë™í•˜ë©° ì ì§„ì ìœ¼ë¡œ ì»¤ì§ (1.0~3ì´ˆ)
            // x ì´ë™ ê±°ë¦¬ë¡œ ì§„í–‰ë„ ê³„ì‚°
            const totalDistance = window.innerWidth + 300;
            const startX = this.sweepStartX;
            const currentDistance = Math.abs(this.x - startX);
            const sweepProgress = Math.min(1, currentDistance / totalDistance);
            
            // ì´ë™í•˜ë©´ì„œ í¬ê¸°ê°€ ì ì§„ì ìœ¼ë¡œ ì»¤ì§
            const minScale = 0.3 + this.randomOffset * 0.5; // 0.3~0.8
            const maxScale = 4.5 + this.randomOffset * 4.5; // 4.5~9.0 (1.5ë°° í™•ëŒ€)
            const scale = minScale + sweepProgress * (maxScale - minScale);
            this.size = this.baseSize * scale;
            
            // ë°˜ëŒ€í¸ìœ¼ë¡œ ë¹ ë¥´ê²Œ ì´ë™ (ì†ë„ë„ ì•½ê°„ ëœë¤)
            this.vx = -this.direction * (45 + this.randomOffset * 10);
            this.x += this.vx;
            
            // yë„ ë¶ˆê·œì¹™í•˜ê²Œ ì´ë™ + shake íš¨ê³¼
            const shakeX = Math.sin(elapsed * 15 + this.randomOffset * 30) * 2;
            const shakeY = Math.sin(elapsed * 12 + this.randomOffset * 25) * 3;
            this.x += shakeX;
            this.y += shakeY + Math.sin(elapsed * 5 + this.randomOffset * 10) * 4;
            
            // íšŒì „ ì§€ì†
            this.rotation += this.rotationSpeed * (1 + sweepProgress);
            
            // íˆ¬ëª…ë„ ë³€í™” (ê°€ê¹Œì›Œì§ˆìˆ˜ë¡ ì•½ê°„ ë” ë¶ˆíˆ¬ëª…)
            this.alpha = this.baseAlpha * (0.7 + sweepProgress * 0.3) + 
                         Math.sin(elapsed * 8 + this.randomOffset * 15) * this.alphaFlicker;
            
            // í™”ë©´ ë°˜ëŒ€í¸ ë²—ì–´ë‚˜ë©´ ì‚¬ë¼ì§
            if ((this.direction > 0 && this.x < -200) || 
                (this.direction < 0 && this.x > window.innerWidth + 200)) {
              this.phase = 3;
            }
          } else if (this.phase === 3) {
            // Phase 3: ë¹ ë¥´ê²Œ ì‚¬ë¼ì§
            this.alpha -= 0.1;
          }
        }
        
        draw(ctx) {
          if (this.alpha > 0 && this.spawned) {
            ctx.save();
            ctx.globalAlpha = Math.max(0, Math.min(1, this.alpha));
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            // ì•½ê°„ ë¶ˆê·œì¹™í•œ ëª¨ì–‘ (ì™„ë²½í•œ ì›ì´ ì•„ë‹Œ)
            ctx.fillStyle = this.color;
            ctx.beginPath();
            
            // íƒ€ì›í˜•ìœ¼ë¡œ ê·¸ë ¤ì„œ ë” ìì—°ìŠ¤ëŸ½ê²Œ
            const scaleX = 1 + Math.sin(this.randomOffset * 10) * 0.2;
            const scaleY = 1 + Math.cos(this.randomOffset * 10) * 0.2;
            ctx.scale(scaleX, scaleY);
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            ctx.fill();
            
            // ë¶€ë“œëŸ¬ìš´ ì—£ì§€ íš¨ê³¼ (ì•½ê°„ì˜ ë¸”ëŸ¬)
            if (this.size > 0.8) {
              ctx.globalAlpha = Math.max(0, Math.min(1, this.alpha)) * 0.3;
              ctx.arc(0, 0, this.size * 1.3, 0, Math.PI * 2);
              ctx.fill();
            }
            
            ctx.restore();
          }
        }
        
        isDead() {
          return this.alpha <= 0;
        }
      }

      // ì…ì(ëª¨ë˜ì•Œ) í´ë˜ìŠ¤
      class Particle {
        constructor(x, y, letterIndex) {
          // ìœ„ì¹˜ (ì²˜ìŒë¶€í„° ìµœì¢… ìœ„ì¹˜ì— ìƒì„±)
          this.x = x;
          this.y = y;
          this.originalX = x;
          this.originalY = y;
          this.letterIndex = letterIndex;
          this.size = Math.random() * 0.4 + 0.3; // 0.3~0.7 ì‚¬ì´ì˜ ë§¤ìš° ì‘ì€ ì…ì
          this.color = `hsl(0, 0%, ${Math.random() * 20 + 70}%)`; // ì€ìƒ‰ìœ¼ë¡œ ë³€ê²½ (70~90% ë°ê¸°)
          this.velocityX = 0;
          this.velocityY = 0;
          this.forming = true; // í˜•ì„± ì¤‘
          this.dispersing = false;
          this.disperseDelay = 0; // í©ì–´ì§€ê¸° ì „ ë”œë ˆì´
          this.alpha = 0; // íˆ¬ëª…í•˜ê²Œ ì‹œì‘
          this.targetAlpha = 1; // ëª©í‘œ íˆ¬ëª…ë„
          this.fadeInDelay = Math.random() * 40; // 0~40 í”„ë ˆì„ ëœë¤ ë”œë ˆì´
          this.fadeInSpeed = Math.random() * 0.02 + 0.015; // 0.015~0.035 ëœë¤ ì†ë„ (ë” ëŠë¦¬ê²Œ)
        }

        update() {
          if (this.forming) {
            // ëœë¤ ë”œë ˆì´ í›„ opacityë§Œ ì„œì„œíˆ ì¦ê°€
            if (this.fadeInDelay > 0) {
              this.fadeInDelay--;
            } else {
              this.alpha += this.fadeInSpeed;
              if (this.alpha >= this.targetAlpha) {
                this.alpha = this.targetAlpha;
                this.forming = false;
              }
            }
          } else if (this.dispersing) {
            // ë”œë ˆì´ê°€ ìˆìœ¼ë©´ ëŒ€ê¸°
            if (this.disperseDelay > 0) {
              this.disperseDelay--;
              return;
            }
            
            // ë°”ëŒì— ë‚ ì•„ê°€ëŠ” íš¨ê³¼ (ë” ëŠë¦¬ê²Œ)
            this.velocityX += 0.1; // 0.15 -> 0.1
            this.velocityY += (Math.random() - 0.5) * 0.2; // 0.3 -> 0.2
            
            // ë°”ëŒì— í”ë“¤ë¦¼
            this.velocityY += Math.sin(Date.now() * 0.01 + this.x) * 0.08; // 0.1 -> 0.08
            
            this.x += this.velocityX;
            this.y += this.velocityY;
            this.alpha -= 0.008; // 0.012 -> 0.008 (ë” ì²œì²œíˆ ì‚¬ë¼ì§)
          }
        }

        draw() {
          if (this.alpha > 0) {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            // íŒŒí‹°í´ì— ê³ ìœ  ìƒ‰ìƒì´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ë°°ê²½ì— ë”°ë¼ ë™ì  ë³€ê²½
            const fillColor = this.color || getBackgroundColorAt(this.x, this.y);
            ctx.fillStyle = fillColor;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        disperse(baseX) {
          this.forming = false;
          this.dispersing = true;
          
          // ì™¼ìª½ íŒŒí‹°í´ë¶€í„° ë¨¼ì € ë‚ ì•„ê°€ë„ë¡ ë”œë ˆì´ ì„¤ì • (ë” ëŠë¦¬ê²Œ)
          const relativeX = this.x - baseX;
          this.disperseDelay = Math.max(0, relativeX * 0.4); // 0.25 -> 0.4ë¡œ ëŠ˜ë¦¼
          
          // ì´ˆê¸° ì†ë„ë„ ì•½ê°„ ëŠë¦¬ê²Œ
          this.velocityX = Math.random() * 1.5 + 0.8; // 2+1 -> 1.5+0.8
          this.velocityY = (Math.random() - 0.7) * 1.5; // *2 -> *1.5
        }
      }

      // ê¸€ì í´ë˜ìŠ¤
      class Letter {
        constructor(char, x, y, index, customFontSize = 80, sentenceId = 0) {
          this.char = char;
          this.x = x;
          this.y = y;
          this.index = index; // ê¸€ì ìƒì„± ìˆœì„œ
          this.fontSize = customFontSize; // ì»¤ìŠ¤í…€ í°íŠ¸ í¬ê¸°
          this.particles = [];
          this.createdAt = Date.now();
          this.dispersed = false;
          this.width = 0; // ê¸€ì ë„ˆë¹„
          this.sentenceId = sentenceId; // ë¬¸ì¥ ID
          this.sentenceStartTime = Date.now(); // ì´ ë¬¸ì¥ì´ ì‹œì‘ëœ ì‹œê°„
          
          this.createParticles();
        }

        createParticles() {
          // ì„ì‹œ ìº”ë²„ìŠ¤ì— ê¸€ì ê·¸ë¦¬ê¸°
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          const fontSize = this.fontSize;
          tempCanvas.width = fontSize * 2;
          tempCanvas.height = fontSize * 2;

          // ì•„ë¼ë¹„ì•ˆ ë‚˜ì´íŠ¸ ëŠë‚Œì˜ ìš°ì•„í•˜ê³  íë¥´ëŠ” ë“¯í•œ í°íŠ¸
          tempCtx.font = `italic bold ${fontSize}px 'Cormorant Garamond', serif`;
          
          // ê¸€ì ë„ˆë¹„ ì¸¡ì •
          const metrics = tempCtx.measureText(this.char);
          this.width = metrics.width;
          
          tempCtx.fillStyle = 'white';
          tempCtx.textAlign = 'center';
          tempCtx.textBaseline = 'middle';
          tempCtx.fillText(this.char, fontSize, fontSize);

          // í”½ì…€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
          const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
          const pixels = imageData.data;

          // ëª¨ë˜ ì…ì ìƒì„± (í”½ì…€ ìƒ˜í”Œë§ - ë” ì´˜ì´˜í•˜ê²Œ)
          const mainParticles = [];
          for (let y = 0; y < tempCanvas.height; y += 1) {
            for (let x = 0; x < tempCanvas.width; x += 1) {
              const index = (y * tempCanvas.width + x) * 4;
              const alpha = pixels[index + 3];
              
              if (alpha > 128) { // ë¶ˆíˆ¬ëª…í•œ í”½ì…€ì—ë§Œ ì…ì ìƒì„±
                // ìœ„ì¹˜ì— ì•½ê°„ì˜ ëœë¤ ì˜¤í”„ì…‹ ì¶”ê°€ (ë” ìì—°ìŠ¤ëŸ¬ìš´ ëª¨ë˜ ëŠë‚Œ)
                const offsetX = (Math.random() - 0.5) * 2;
                const offsetY = (Math.random() - 0.5) * 2;
                const px = this.x + x - fontSize + offsetX;
                const py = this.y + y - fontSize + offsetY;
                this.particles.push(new Particle(px, py, letters.length));
                mainParticles.push({ x: px, y: py });
              }
            }
          }
          
          // ê¸€ì ì£¼ë³€ì— ì¶”ê°€ ëœë¤ íŒŒí‹°í´ ìƒì„± (ëª¨ë˜ê°€ í©ì–´ì§„ ëŠë‚Œ)
          // ê¸€ì í¬ê¸°ì— ë”°ë¼ ì¶”ê°€ íŒŒí‹°í´ ë¹„ìœ¨ ì¡°ì • (ì‘ì€ ê¸€ì”¨ëŠ” ì ê²Œ)
          const extraParticleRatio = Math.min(0.5, (fontSize / 80) * 0.5);
          const extraParticleCount = Math.floor(mainParticles.length * extraParticleRatio);
          
          for (let i = 0; i < extraParticleCount; i++) {
            // ê¸°ì¡´ íŒŒí‹°í´ ì¤‘ ëœë¤í•˜ê²Œ ì„ íƒ
            const baseParticle = mainParticles[Math.floor(Math.random() * mainParticles.length)];
            if (baseParticle) {
              // ì£¼ë³€ 3~10í”½ì…€ ë²”ìœ„ì— ëœë¤ ë°°ì¹˜
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * 7 + 3;
              const px = baseParticle.x + Math.cos(angle) * distance;
              const py = baseParticle.y + Math.sin(angle) * distance;
              this.particles.push(new Particle(px, py, letters.length));
            }
          }
        }

        update() {
          // íŠ¹ë³„ ë©”ì‹œì§€ë“¤ì€ ë³„ë„ ì²˜ë¦¬
          if (this.isWishMessage || this.isIntroMessage || this.isKoreanWarning || this.isTouchHint || this.isClickHint || this.isEnterHint) {
            this.particles.forEach(p => p.update());
            return;
          }
          
          // ì´ ë¬¸ì¥ì˜ ë§ˆì§€ë§‰ ì…ë ¥ ì‹œê°„ ì°¾ê¸° (ê°™ì€ sentenceIdë¥¼ ê°€ì§„ ê¸€ìë“¤ ì¤‘)
          const sameSentenceLetters = letters.filter(l => l.sentenceId === this.sentenceId);
          const sentenceLastInputTime = Math.max(...sameSentenceLetters.map(l => l.createdAt));
          
          // ì´ ë¬¸ì¥ ê¸°ì¤€ìœ¼ë¡œ ì‹œê°„ ê³„ì‚°
          const timeSinceSentenceLastInput = Date.now() - sentenceLastInputTime;
          const timeSinceCreation = Date.now() - this.createdAt;
          
          // ê°™ì€ ë¬¸ì¥ ë‚´ì—ì„œì˜ ì¸ë±ìŠ¤ ê³„ì‚°
          const sentenceIndex = sameSentenceLetters.findIndex(l => l === this);
          
          // ê¸°ë³¸ ëŒ€ê¸° ì‹œê°„ì„ 1.5ì´ˆë¡œ ëŠ˜ë¦¬ê³ , ìˆœì°¨ ë”œë ˆì´ë„ ëŠ˜ë¦¼
          const disperseDelay = 1500 + (Math.pow(sentenceIndex, 0.6) * 150);
          
          // í˜•ì„±ì´ ì™„ë£Œë˜ê³ (1.5ì´ˆ ê²½ê³¼) + ë¬¸ì¥ ë§ˆì§€ë§‰ ì…ë ¥ + ìˆœì°¨ ë”œë ˆì´ í›„ í©ì–´ì§
          if (!this.dispersed && timeSinceCreation > 1500 && timeSinceSentenceLastInput > disperseDelay) {
            this.dispersed = true;
            
            // ë¬¸ì¥ì˜ ë§ˆì§€ë§‰ ê¸€ìì¼ ë•Œ ì—”í„° ì—†ì´ ì‚¬ë¼ì§ ì¹´ìš´í„° ì¦ê°€
            const isLastInSentence = sentenceIndex === sameSentenceLetters.length - 1;
            if (isLastInSentence) {
              sentencesWithoutEnter++;
              console.log(`ğŸ“ Sentence dispersed without Enter. Count: ${sentencesWithoutEnter}`);
              
              // 3ë²ˆì§¸ ì—”í„° ì—†ì´ ì‚¬ë¼ì§„ ë¬¸ì¥ì´ë©´ Enter íŒíŠ¸ ìƒì„±
              if (sentencesWithoutEnter >= 3 && !wishMessage && !enterHintShown) {
                createEnterHint();
                sentencesWithoutEnter = 0; // ë¦¬ì…‹
              }
            }
            
            // ê¸€ìì˜ x ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ë¶€í„° ë‚ ì•„ê°€ë„ë¡
            this.particles.forEach(p => p.disperse(this.x));
          }

          this.particles.forEach(p => p.update());
        }
        
        checkShouldDisperse() {
          // í˜•ì„±ì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸
          const timeSinceCreation = Date.now() - this.createdAt;
          return timeSinceCreation > 1000;
        }

        draw() {
          this.particles.forEach(p => p.draw());
        }

        isFinished() {
          // ëª¨ë“  ì…ìê°€ ì‚¬ë¼ì¡ŒëŠ”ì§€ í™•ì¸
          return this.dispersed && this.particles.every(p => p.alpha <= 0);
        }
      }

      // ê¸€ìë“¤ì„ ì €ì¥í•˜ëŠ” ë°°ì—´
      let letters = [];
      let currentX = window.innerWidth / 2;
      let currentY = window.innerHeight / 2;
      let mouseX = window.innerWidth / 2;
      let mouseY = window.innerHeight / 2;
      let isTyping = false; // íƒ€ì´í•‘ ì¤‘ì¸ì§€ í™•ì¸
      let lastInputTime = Date.now(); // ë§ˆì§€ë§‰ ì…ë ¥ ì‹œê°„
      let currentSentenceId = 0; // í˜„ì¬ ë¬¸ì¥ ID (ë§ˆìš°ìŠ¤ ì›€ì§ì¼ ë•Œë§ˆë‹¤ ì¦ê°€)

      // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì¶”ì  (í•­ìƒ ì¶”ì )
      let lastMouseLogTime = 0;
      let mouseHasMoved = false; // ë§ˆìš°ìŠ¤ê°€ ì›€ì§ì˜€ëŠ”ì§€ ì¶”ì 
      let lastMouseX = window.innerWidth / 2;
      let lastMouseY = window.innerHeight / 2;
      
      window.addEventListener('mousemove', function(event) {
        mouseX = event.clientX;
        mouseY = event.clientY;
        
        // ë§ˆìš°ìŠ¤ê°€ ì›€ì§ì˜€ëŠ”ì§€ ê°ì§€ (10í”½ì…€ ì´ìƒ ì›€ì§ì´ë©´)
        const mouseMoveDistance = Math.sqrt(
          Math.pow(mouseX - lastMouseX, 2) + Math.pow(mouseY - lastMouseY, 2)
        );
        
        if (mouseMoveDistance > 10) {
          mouseHasMoved = true;
          console.log('ğŸ–±ï¸ Mouse moved significantly, next typing will start at new position');
        }
        
        lastMouseX = mouseX;
        lastMouseY = mouseY;
        
        // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ 1ì´ˆë§ˆë‹¤ ì½˜ì†” ì¶œë ¥
        const now = Date.now();
        if (now - lastMouseLogTime > 1000) {
          console.log('Mouse Position:', { x: mouseX, y: mouseY });
          lastMouseLogTime = now;
        }
      });

      // ë§ˆìš°ìŠ¤ í´ë¦­ ì‹œ ì¹´ë©”ë¼ ìœ„ì¹˜ ì¶œë ¥
      window.addEventListener('click', function(event) {
        console.log('ğŸ“¸ Camera Position:', {
          x: camera.position.x.toFixed(2), 
          y: camera.position.y.toFixed(2), 
          z: camera.position.z.toFixed(2)
        });
        
        // ì²« í´ë¦­ íŒíŠ¸ê°€ ì´ë¯¸ í‘œì‹œëœ ê²½ìš° ë¬´ì‹œ
        if (clickHintShown) {
          console.log('ğŸš« Click hint already shown, ignoring click event');
          return;
        }
        
        // í´ë¦­ íŒíŠ¸ ìƒì„± (ì´ì „ íŒíŠ¸ê°€ ìˆìœ¼ë©´ ë¶„ì‚°ì‹œí‚¤ê³  ìƒˆë¡œ ìƒì„±)
        if (clickHintMessage) {
          disperseClickHint();
        }
        createClickHint();
      });
      
      // í„°ì¹˜ ì´ë²¤íŠ¸ë„ ì¶”ê°€ (ëª¨ë°”ì¼ ëŒ€ì‘)
      window.addEventListener('touchstart', function(event) {
        // ì²« í´ë¦­ íŒíŠ¸ê°€ ì´ë¯¸ í‘œì‹œëœ ê²½ìš° ë¬´ì‹œ
        if (clickHintShown) {
          console.log('ğŸš« Click hint already shown, ignoring touch event');
          return;
        }
        
        // í´ë¦­ íŒíŠ¸ ìƒì„± (ì´ì „ íŒíŠ¸ê°€ ìˆìœ¼ë©´ ë¶„ì‚°ì‹œí‚¤ê³  ìƒˆë¡œ ìƒì„±)
        if (clickHintMessage) {
          disperseClickHint();
        }
        createClickHint();
      });

      // í•œê¸€ ì…ë ¥ ê°ì§€ í•¨ìˆ˜
      function isKorean(text) {
        return /[ã„±-ã…|ã…-ã…£|ê°€-í£]/.test(text);
      }
      
      // touch íŒíŠ¸ ë©”ì‹œì§€ ìƒì„± í•¨ìˆ˜ (ë‹¨ìˆœ ë²„ì „)
      function createTouchHint() {
        if (touchHintMessage || touchHintShown) return; // ì´ë¯¸ ìƒì„±ë˜ì—ˆê±°ë‚˜ í•œ ë²ˆ í‘œì‹œëœ ê²½ìš° ë¬´ì‹œ
        
        touchHintShown = true; // í‘œì‹œ í”Œë˜ê·¸ ì„¤ì •
        console.log('ğŸ’¡ Creating simple touch hint message!');
        touchHintMessage = [];
        touchHintStartTime = Date.now();
        const message = "touch?";
        
        // ë¨í”„ ì•„ë˜ì— ìœ„ì¹˜ (í•œê¸€ ê²½ê³  ë©”ì‹œì§€ì™€ ê°™ì€ ìœ„ì¹˜)
        const msgY = window.innerHeight * 0.75;
        
        // ì „ì²´ ë„ˆë¹„ ê³„ì‚° (ì‘ì€ ê¸€ì”¨)
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.font = `italic bold 60px 'Cormorant Garamond', serif`;
        
        let totalMsgWidth = 0;
        for (let i = 0; i < message.length; i++) {
          const char = message[i];
          const metrics = tempCtx.measureText(char);
          const spacing = Math.min(Math.max(metrics.width + 6, 30), 45);
          totalMsgWidth += spacing;
        }
        
        // ì¤‘ì•™ì •ë ¬ ì‹œì‘ ìœ„ì¹˜
        const msgX = (window.innerWidth - totalMsgWidth) / 2;
        let msgCurrentX = msgX;
        
        for (let i = 0; i < message.length; i++) {
          const char = message[i];
          const msgLetter = new Letter(char, msgCurrentX, msgY, i, 60, -1); // sentenceId -1 (íŠ¹ë³„)
          msgLetter.isTouchHint = true;
          msgLetter.revealDelay = i * 150; // 150ms ê°„ê²©ìœ¼ë¡œ ìˆœì°¨ ë“±ì¥
          msgLetter.revealed = false;
          
          // ëª¨ë“  íŒŒí‹°í´ì„ íˆ¬ëª…í•˜ê²Œ ì‹œì‘ + í™©ê¸ˆìƒ‰ìœ¼ë¡œ ì„¤ì • (ì§€ë‹ˆ íŒíŠ¸)
          msgLetter.particles.forEach(p => {
            p.alpha = 0;
            p.targetAlpha = 1;
            p.forming = false;
            p.originalX = p.x;
            p.originalY = p.y;
            // í™©ê¸ˆìƒ‰ íŒŒí‹°í´
            p.color = `hsl(45, 85%, ${Math.random() * 15 + 60}%)`;
          });
          
          touchHintMessage.push(msgLetter);
          const spacing = Math.min(Math.max(msgLetter.width + 6, 30), 45);
          msgCurrentX += spacing;
        }
      }
      
      // touch íŒíŠ¸ ë©”ì‹œì§€ ë‚ ë¦¬ê¸° í•¨ìˆ˜ (ì¼ë°˜ ê¸€ìì™€ ë™ì¼í•œ ë¡œì§)
      function disperseTouchHint() {
        if (!touchHintMessage) return;
        
        console.log('ğŸŒªï¸ Dispersing touch hint message!');
        
        touchHintMessage.forEach((msgLetter, index) => {
          if (msgLetter.revealed) {
            // ê¸€ìì˜ x ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ë¶€í„° ë‚ ì•„ê°€ë„ë¡ (ì¼ë°˜ ê¸€ìì™€ ë™ì¼)
            msgLetter.particles.forEach(p => p.disperse(msgLetter.x));
          }
        });
      }

      // Enter í‚¤ íŒíŠ¸ ë©”ì‹œì§€ ìƒì„± í•¨ìˆ˜
      function createEnterHint() {
        if (enterHintMessage || enterHintShown) return; // ì´ë¯¸ ìƒì„±ë˜ì—ˆê±°ë‚˜ í•œ ë²ˆ í‘œì‹œëœ ê²½ìš° ë¬´ì‹œ
        
        enterHintShown = true; // í‘œì‹œ í”Œë˜ê·¸ ì„¤ì •
        console.log('ğŸ’¡ Creating Enter key hint message!');
        enterHintMessage = [];
        enterHintStartTime = Date.now();
        const message = 'type and press "enter" to talk with me';
        
        // ë¨í”„ ì•„ë˜ì— ìœ„ì¹˜ (touch íŒíŠ¸ì™€ ê°™ì€ ìœ„ì¹˜)
        const msgY = window.innerHeight * 0.75;
        
        // ì „ì²´ ë„ˆë¹„ ê³„ì‚° (ì‘ì€ ê¸€ì”¨)
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.font = `italic bold 50px 'Cormorant Garamond', serif`;
        
        let totalMsgWidth = 0;
        for (let i = 0; i < message.length; i++) {
          const char = message[i];
          const metrics = tempCtx.measureText(char);
          const spacing = Math.min(Math.max(metrics.width + 4, 25), 40);
          totalMsgWidth += spacing;
        }
        
        // ì¤‘ì•™ì •ë ¬ ì‹œì‘ ìœ„ì¹˜
        const msgX = (window.innerWidth - totalMsgWidth) / 2;
        let msgCurrentX = msgX;
        
        for (let i = 0; i < message.length; i++) {
          const char = message[i];
          const msgLetter = new Letter(char, msgCurrentX, msgY, i, 50, -3); // sentenceId -3 (íŠ¹ë³„)
          msgLetter.isEnterHint = true;
          msgLetter.revealDelay = i * 80; // 80ms ê°„ê²©ìœ¼ë¡œ ìˆœì°¨ ë“±ì¥
          msgLetter.revealed = false;
          
          // ëª¨ë“  íŒŒí‹°í´ì„ íˆ¬ëª…í•˜ê²Œ ì‹œì‘ + í™©ê¸ˆìƒ‰ìœ¼ë¡œ ì„¤ì • (ì§€ë‹ˆ íŒíŠ¸)
          msgLetter.particles.forEach(p => {
            p.alpha = 0;
            p.targetAlpha = 1;
            p.forming = false;
            p.originalX = p.x;
            p.originalY = p.y;
            // í™©ê¸ˆìƒ‰ íŒŒí‹°í´
            p.color = `hsl(45, 85%, ${Math.random() * 15 + 60}%)`;
          });
          
          enterHintMessage.push(msgLetter);
          const spacing = Math.min(Math.max(msgLetter.width + 4, 25), 40);
          msgCurrentX += spacing;
        }
      }

      // Enter íŒíŠ¸ ë©”ì‹œì§€ ë‚ ë¦¬ê¸° í•¨ìˆ˜ (ì¼ë°˜ ê¸€ìì™€ ë™ì¼í•œ ë¡œì§)
      function disperseEnterHint() {
        if (!enterHintMessage) return;
        
        console.log('ğŸŒªï¸ Dispersing Enter hint message!');
        
        enterHintMessage.forEach((msgLetter, index) => {
          if (msgLetter.revealed) {
            // ê¸€ìì˜ x ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ë¶€í„° ë‚ ì•„ê°€ë„ë¡ (ì¼ë°˜ ê¸€ìì™€ ë™ì¼)
            msgLetter.particles.forEach(p => p.disperse(msgLetter.x));
          }
        });
      }

      // í´ë¦­ íŒíŠ¸ ìƒì„± í•¨ìˆ˜
      function createClickHint() {
        if (clickHintMessage || clickHintShown) return; // ì´ë¯¸ ìƒì„±ë˜ì—ˆê±°ë‚˜ í•œ ë²ˆ í‘œì‹œëœ ê²½ìš° ë¬´ì‹œ
        
        clickHintShown = true; // í‘œì‹œ í”Œë˜ê·¸ ì„¤ì •
        console.log('ğŸ’¡ Creating click hint message!');
        clickHintMessage = [];
        clickHintStartTime = Date.now();
        const message = "I only recognize keyboard input and mouse position";
        
        // ë¨í”„ ìœ„ìª½ì— ìœ„ì¹˜ (ë” ìœ„ë¡œ)
        const msgY = window.innerHeight * 0.15;
        
        // ì „ì²´ ë„ˆë¹„ ê³„ì‚° (ì‘ì€ ê¸€ì”¨)
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.font = `italic 40px 'Cormorant Garamond', serif`;
        
        let totalMsgWidth = 0;
        for (let i = 0; i < message.length; i++) {
          const char = message[i];
          const metrics = tempCtx.measureText(char);
          const spacing = Math.min(Math.max(metrics.width + 3, 20), 35);
          totalMsgWidth += spacing;
        }
        
        // ì¤‘ì•™ì •ë ¬ ì‹œì‘ ìœ„ì¹˜
        const msgX = (window.innerWidth - totalMsgWidth) / 2;
        let msgCurrentX = msgX;
        
        for (let i = 0; i < message.length; i++) {
          const char = message[i];
          const msgLetter = new Letter(char, msgCurrentX, msgY, i, 40, -2); // sentenceId -2 (íŠ¹ë³„)
          msgLetter.isClickHint = true;
          msgLetter.revealDelay = i * 100; // 100ms ê°„ê²©ìœ¼ë¡œ ìˆœì°¨ ë“±ì¥
          msgLetter.revealed = false;
          
          // ëª¨ë“  íŒŒí‹°í´ì„ íˆ¬ëª…í•˜ê²Œ ì‹œì‘ + ì€ìƒ‰ìœ¼ë¡œ ì„¤ì • (ì‚¬ìš©ì ìƒ‰ìƒ)
          msgLetter.particles.forEach(p => {
            p.alpha = 0;
            p.targetAlpha = 1;
            p.forming = false;
            p.originalX = p.x;
            p.originalY = p.y;
            // í™©ê¸ˆìƒ‰ íŒŒí‹°í´ (ì§€ë‹ˆ ìƒ‰ìƒ)
            p.color = `hsl(45, 85%, ${Math.random() * 15 + 60}%)`;
          });
          
          clickHintMessage.push(msgLetter);
          const spacing = Math.min(Math.max(msgLetter.width + 3, 20), 35);
          msgCurrentX += spacing;
        }
      }

      // í´ë¦­ íŒíŠ¸ ë¶„ì‚° í•¨ìˆ˜ (ì¼ë°˜ ê¸€ìì™€ ë™ì¼í•œ ë¡œì§)
      function disperseClickHint() {
        if (!clickHintMessage) return;
        
        console.log('ğŸŒªï¸ Dispersing click hint message!');
        
        clickHintMessage.forEach((msgLetter, index) => {
          if (msgLetter.revealed) {
            // ê¸€ìì˜ x ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ë¶€í„° ë‚ ì•„ê°€ë„ë¡ (ì¼ë°˜ ê¸€ìì™€ ë™ì¼)
            msgLetter.particles.forEach(p => p.disperse(msgLetter.x));
          }
        });
        
        clickHintMessage = null; // ë©”ì‹œì§€ ì œê±°
      }

      // í•œê¸€ ê²½ê³  ë©”ì‹œì§€ ìƒì„± í•¨ìˆ˜
      function createKoreanWarningMessage() {
        if (koreanWarningMessage || koreanHintShown) return; // ì´ë¯¸ ìƒì„±ë˜ì—ˆê±°ë‚˜ í•œ ë²ˆ í‘œì‹œëœ ê²½ìš° ë¬´ì‹œ
        
        koreanHintShown = true; // í‘œì‹œ í”Œë˜ê·¸ ì„¤ì •
        koreanWarningMessage = [];
        koreanWarningStartTime = Date.now();
        const message = "I can't speak Korean...";
        
        // ë¨í”„ ì•„ë˜ì— ìœ„ì¹˜ (ë¨í”„ê°€ í™”ë©´ ì¤‘ì•™ ì•„ë˜ìª½ì— ìˆìœ¼ë¯€ë¡œ)
        const msgY = window.innerHeight * 0.75;
        
        // ì „ì²´ ë„ˆë¹„ ê³„ì‚° (ì‘ì€ ê¸€ì”¨)
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.font = `italic bold 50px 'Cormorant Garamond', serif`; // 70px -> 50px
        
        let totalMsgWidth = 0;
        for (let i = 0; i < message.length; i++) {
          const char = message[i];
          const metrics = tempCtx.measureText(char);
          // ìê°„ì„ ì¤„ì„: ê¸°ì¡´ë³´ë‹¤ ì‘ê²Œ ì„¤ì •
          const spacing = char === ' ' ? 18 : Math.min(Math.max(metrics.width + 4, 25), 35); // 25->18, 40->25, 55->35
          totalMsgWidth += spacing;
        }
        
        // ì¤‘ì•™ì •ë ¬ ì‹œì‘ ìœ„ì¹˜
        const msgX = (window.innerWidth - totalMsgWidth) / 2;
        let msgCurrentX = msgX;
        
        for (let i = 0; i < message.length; i++) {
          const char = message[i];
          const msgLetter = new Letter(char, msgCurrentX, msgY, i, 50); // 70 -> 50px
          msgLetter.isKoreanWarning = true;
          msgLetter.revealDelay = i * 100; // 100ms ê°„ê²©ìœ¼ë¡œ ìˆœì°¨ ë“±ì¥
          msgLetter.revealed = false;
          
          // ëª¨ë“  íŒŒí‹°í´ì„ íˆ¬ëª…í•˜ê²Œ ì‹œì‘ + í™©ê¸ˆìƒ‰ìœ¼ë¡œ ì„¤ì • (ì§€ë‹ˆ ë©”ì‹œì§€)
          msgLetter.particles.forEach(p => {
            p.alpha = 0;
            p.targetAlpha = 1;
            p.forming = false;
            p.originalX = p.x; // ì›ë˜ ìœ„ì¹˜ ì €ì¥ (ì¼ë ì„ìš©)
            p.originalY = p.y;
            // í™©ê¸ˆìƒ‰ íŒŒí‹°í´ë¡œ ë³€ê²½
            p.color = `hsl(45, 85%, ${Math.random() * 15 + 60}%)`; // í™©ê¸ˆìƒ‰ (60~75% ë°ê¸°)
          });
          
          koreanWarningMessage.push(msgLetter);
          // ë™ì¼í•œ ìê°„ ì ìš©
          const spacing = char === ' ' ? 18 : Math.min(Math.max(msgLetter.width + 4, 25), 35);
          msgCurrentX += spacing;
        }
        
        console.log('âš ï¸ Korean warning message created!');
      }

      // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬ (íƒ€ì´í•‘ + ì¹´ë©”ë¼ íšŒì „)
      document.addEventListener('keydown', function(event) {
        console.log('Key pressed:', event.key);
        
        // í‚¤ë³´ë“œ ì…ë ¥ì´ ìˆìœ¼ë©´ í´ë¦­ íŒíŠ¸ ë¶„ì‚°
        if (clickHintMessage && event.key !== 'ArrowLeft' && event.key !== 'ArrowRight') {
          disperseClickHint();
        }

        // ì¹´ë©”ë¼ íšŒì „ (ë°©í–¥í‚¤) - ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ê³„ì† íšŒì „
        if (event.key === 'ArrowLeft') {
          isRotatingLeft = true;
          return;
        } else if (event.key === 'ArrowRight') {
          isRotatingRight = true;
          return;
        }
        
        // íƒ€ì´í•‘ ì²˜ë¦¬
        if (event.key === 'Backspace') {
          event.preventDefault();
          
          // Make your wish ì´í›„: í‚¤ì›Œë“œì˜ ë§ˆì§€ë§‰ ê¸€ì ì œê±° (í™”ë©´ì—ë„ ì ìš©)
          if (wishMessage && wishInputText.length > 0) {
            wishInputText = wishInputText.slice(0, -1);
            console.log('Wish keyword:', wishInputText);
            // í™”ë©´ì—ë„ ë°˜ì˜ë˜ë„ë¡ return ì œê±°
          }
          
          // ë§ˆì§€ë§‰ ê¸€ì ì œê±°
          if (letters.length > 0) {
            const lastLetter = letters.pop();
            const spacing = Math.min(Math.max(lastLetter.width + 8, 45), 58);
            currentX -= spacing;
            // í˜„ì¬ í…ìŠ¤íŠ¸ì—ì„œë„ ë§ˆì§€ë§‰ ê¸€ì ì œê±°
            currentTypedText = currentTypedText.slice(0, -1);
          }
          // ëª¨ë“  ê¸€ìê°€ ì§€ì›Œì§€ë©´ íƒ€ì´í•‘ ìƒíƒœ í•´ì œ
          if (letters.length === 0) {
            isTyping = false;
            currentTypedText = '';
          }
          lastInputTime = Date.now();
        } else if (event.key === 'Enter') {
          event.preventDefault();
          
          // Enter í‚¤ë¥¼ ëˆŒë €ìœ¼ë¯€ë¡œ ì—”í„° ì—†ì´ ì‚¬ë¼ì§ ì¹´ìš´í„° ë¦¬ì…‹
          sentencesWithoutEnter = 0;
          
          // Enter íŒíŠ¸ê°€ ìˆìœ¼ë©´ ë‚ ë¦¬ê¸°
          if (enterHintMessage) {
            disperseEnterHint();
          }
          
          // touch ìƒí˜¸ì‘ìš©ì´ í™œì„±í™”ë˜ì–´ ìˆì„ ë•Œë§Œ ì²˜ë¦¬
          if (touchInteractionsEnabled) {
            // ë¨í”„ ê´€ë ¨ í‚¤ì›Œë“œ í¬í•¨ ì—¬ë¶€ í™•ì¸
            console.log('Enter pressed. Current text:', currentTypedText);
            const lampKeywords = ['touch', 'rub', 'polish', 'scratch', 'stroke', 'caress', 'pat', 'tap'];
            const textLower = currentTypedText.toLowerCase();
            const hasLampKeyword = lampKeywords.some(keyword => textLower.includes(keyword));
            
            if (hasLampKeyword) {
              // ì„¸ ë²ˆì§¸ touch ì´í›„ì—ëŠ” ë¬´ì‹œ
              if (touchCount >= 3) {
                console.log('ğŸš« Already touched 3 times, ignoring additional touch');
              } else {
                touchCount++;
                console.log('âœ¨ LAMP INTERACTION DETECTED! Count:', touchCount);
                
                // ë¨í”„ í”ë“¤ë¦¼ ì‹œì‘
                lampShaking = true;
                lampShakeStartTime = Date.now();
                console.log('ğŸª” Lamp shaking started!');
                
                // ì„¸ ë²ˆì§¸ touchì¼ ë•Œ ì¹´ë©”ë¼ íšŒì „ ì‹œì‘ (í”ë“¤ë¦¼ê³¼ ë™ì‹œì—)
                if (touchCount === 3) {
                  console.log('ğŸ“¸ Starting camera return to initial position');
                  isCameraReturning = true;
                  cameraReturnStartTime = Date.now();
                  cameraStartAngle = cameraAngle;
                  cameraTargetAngle = Math.atan2(-4.35, 1.98); // ì´ˆê¸° ê°ë„
                }
                
                // touch íŒíŠ¸ ë©”ì‹œì§€ê°€ ìˆìœ¼ë©´ ë‚ ì•„ê°€ê²Œ í•¨
                if (touchHintMessage) {
                  disperseTouchHint();
                }
                
                // touchê°€ ì—†ëŠ” ë¬¸ì¥ ì™„ì„± ì¹´ìš´í„° ë¦¬ì…‹
                completedSentences = 0;
              }
            } else {
              // touchê°€ ì—†ëŠ” ë¬¸ì¥ ì™„ì„±
              completedSentences++;
              console.log(`ğŸ“ Sentence completed without touch. Count: ${completedSentences}`);
              
              // ì„¸ ë²ˆì§¸ ë¬¸ì¥ì´ë©´ íŒíŠ¸ ìƒì„± (wishMessageê°€ ì—†ì„ ë•Œë§Œ)
              if (completedSentences >= 3 && !wishMessage) {
                createTouchHint();
                completedSentences = 0; // ë¦¬ì…‹
              }
            }
          }
          
          // Make your wish ì´í›„: ì†Œì› í‚¤ì›Œë“œ ì²˜ë¦¬ (Enter í‚¤ë¡œë§Œ)
          if (wishMessage && wishInputText.trim() !== '') {
            const text = wishInputText.trim().toLowerCase();
            console.log('ğŸŒ Analyzing wish on Enter:', text);
            
            // í…ìŠ¤íŠ¸ì—ì„œ í‚¤ì›Œë“œ ì°¾ê¸° (keywords.jsì—ì„œ ë¶ˆëŸ¬ì˜¨ ë°ì´í„° ì‚¬ìš©)
            let detectedKeyword = null;
            for (const [category, keywords] of Object.entries(keywordMap)) {
              if (keywords.some(keyword => text.includes(keyword))) {
                detectedKeyword = category;
                break;
              }
            }
            
            if (detectedKeyword && backgroundImages[detectedKeyword]) {
              const imageUrl = backgroundImages[detectedKeyword];
              
              // body ë°°ê²½ ì„¤ì •
              document.body.style.backgroundImage = `url('${imageUrl}')`;
              document.body.style.backgroundSize = 'cover';
              document.body.style.backgroundPosition = 'center';
              document.body.style.backgroundRepeat = 'no-repeat';
              document.body.style.backgroundAttachment = 'fixed';
              
              // Three.js ë°°ê²½ íˆ¬ëª…í•˜ê²Œ
              scene.background = null;
              renderer.setClearColor(0x000000, 0); // ì™„ì „ íˆ¬ëª…
              
              // ë°”ë‹¥ ì œê±°
              if (window.floorMesh) {
                scene.remove(window.floorMesh);
              }
              
              // ì•ˆê°œ ì œê±°
              scene.fog = null;
              
              // ë°°ê²½ ì´ë¯¸ì§€ë¥¼ ìˆ¨ê²¨ì§„ canvasì— ê·¸ë ¤ì„œ í”½ì…€ ë°ì´í„° ì½ê¸°
              currentBackgroundImage = imageUrl;
              const bgImage = new Image();
              bgImage.crossOrigin = 'anonymous';
              bgImage.onload = function() {
                bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                bgCtx.drawImage(bgImage, 0, 0, bgCanvas.width, bgCanvas.height);
                bgImageData = bgCtx.getImageData(0, 0, bgCanvas.width, bgCanvas.height);
                console.log('ğŸ“¸ Background image data loaded for particle color adjustment');
                
                // ë°°ê²½ ì´ë¯¸ì§€ í‰ê·  ë°ê¸° ê³„ì‚° ë° ë¨í”„ ì¡°ëª… ì¡°ì •
                adjustLampLightingBasedOnBackground(bgImageData);
              };
              bgImage.onerror = function() {
                console.warn('âš ï¸ Failed to load background image for color sampling');
              };
              bgImage.src = imageUrl;
              
              console.log(`âœ¨ Background changed to: ${detectedKeyword}!`);
              wishInputText = ''; // ë¦¬ì…‹
            } else {
              console.log('âš ï¸ No matching keyword found in wish. Try: ë¶€ì/rich/wealth, ì‚¬ë‘/love, ê±´ê°•/health, ì„±ê³µ/success, í–‰ë³µ/happiness, ocean, forest, tokyo, space, etc.');
            }
          }
          
          // ì¤„ë°”ê¿ˆ - ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ìƒˆë¡œìš´ ì¤„ ì‹œì‘
          isTyping = false;
          currentX = mouseX;
          currentY = mouseY;
          currentTypedText = ''; // í…ìŠ¤íŠ¸ ë¦¬ì…‹
          lastInputTime = Date.now();
        } else if (event.key === ' ') {
          event.preventDefault();
          
          // Make your wish ì´í›„: í‚¤ì›Œë“œì— ìŠ¤í˜ì´ìŠ¤ ì¶”ê°€ (í™”ë©´ì—ë„ í‘œì‹œ)
          if (wishMessage) {
            wishInputText += ' ';
            console.log('Wish keyword:', wishInputText);
            // ê¸€ìëŠ” í™”ë©´ì—ë„ í‘œì‹œí•˜ë„ë¡ return ì œê±°
          }
          
          // ìŠ¤í˜ì´ìŠ¤
          currentX += 25;
          currentTypedText += ' ';
          isTyping = true;
          lastInputTime = Date.now();
        } else if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
          event.preventDefault();
          
          // í•œê¸€ ì…ë ¥ ê°ì§€ - ì§€ë‹ˆ ë©”ì‹œì§€ë§Œ ìƒì„±í•˜ê³  ê¸€ìëŠ” ê·¸ëŒ€ë¡œ í‘œì‹œ
          if (isKorean(event.key)) {
            console.log('ğŸ‡°ğŸ‡· Korean input detected:', event.key);
            createKoreanWarningMessage();
            // í•œê¸€ë„ í™”ë©´ì— í‘œì‹œí•˜ë„ë¡ return ì œê±°
          }
          
          // Make your wish ì´í›„: í‚¤ì›Œë“œ ì…ë ¥ (í™”ë©´ì—ë„ í‘œì‹œ)
          if (wishMessage) {
            wishInputText += event.key;
            console.log('Wish keyword:', wishInputText);
            // ê¸€ìëŠ” í™”ë©´ì—ë„ í‘œì‹œ
          }
          
          // ìƒˆë¡œìš´ íƒ€ì´í•‘ ì‹œì‘ ì¡°ê±´: 
          // 1) íƒ€ì´í•‘ ì¤‘ì´ ì•„ë‹ˆê±°ë‚˜ 
          // 2) ë§ˆìš°ìŠ¤ê°€ ì›€ì§ì˜€ê±°ë‚˜
          // 3) ë§ˆì§€ë§‰ ì…ë ¥ìœ¼ë¡œë¶€í„° 2ì´ˆ ì´ìƒ ì§€ë‚¬ê±°ë‚˜
          // 4) í˜„ì¬ ìœ„ì¹˜ê°€ í™”ë©´ ëì— ê°€ê¹Œìš°ë©´
          const timeSinceLastInput = Date.now() - lastInputTime;
          const shouldStartNewLine = !isTyping || 
                                   mouseHasMoved ||
                                   timeSinceLastInput > 2000 || 
                                   currentX > canvas.width - 100;
          
          if (shouldStartNewLine) {
            currentX = mouseX;
            currentY = mouseY;
            mouseHasMoved = false; // ë§ˆìš°ìŠ¤ ì´ë™ í”Œë˜ê·¸ ë¦¬ì…‹
            currentSentenceId++; // ìƒˆë¡œìš´ ë¬¸ì¥ ID í• ë‹¹
            console.log('ğŸ–±ï¸ Starting new typing at mouse position:', { x: mouseX, y: mouseY, sentenceId: currentSentenceId });
          }

          // ìƒˆ ê¸€ì ìƒì„± (ì¸ë±ìŠ¤ì™€ ë¬¸ì¥ ID ì „ë‹¬)
          const letter = new Letter(event.key, currentX, currentY, letters.length, 80, currentSentenceId);
          letters.push(letter);
          
          // í˜„ì¬ íƒ€ì´í•‘ í…ìŠ¤íŠ¸ì— ì¶”ê°€
          currentTypedText += event.key;
          
          // ë¨í”„ ê´€ë ¨ í‚¤ì›Œë“œê°€ ì™„ì„±ë˜ì—ˆëŠ”ì§€ ì‹¤ì‹œê°„ ì²´í¬
          const lampKeywordsCheck = ['touch', 'rub', 'polish', 'scratch', 'stroke', 'caress', 'pat', 'tap'];
          const detectedKeyword = lampKeywordsCheck.find(kw => currentTypedText.toLowerCase().includes(kw));
          if (detectedKeyword) {
            console.log(`"${detectedKeyword}" detected in text:`, currentTypedText);
          }
          
          // ê¸€ì ë„ˆë¹„ + ê°„ê²©(8px), ìµœì†Œ 45px, ìµœëŒ€ 58px - ë„“ì€ ê¸€ìë„ ì ì ˆí•œ ê°„ê²©
          const spacing = Math.min(Math.max(letter.width + 8, 45), 58);
          currentX += spacing;
          isTyping = true; // íƒ€ì´í•‘ ìƒíƒœë¡œ ì „í™˜
          lastInputTime = Date.now();
        }
      });

      // í‚¤ë³´ë“œ keyup ì²˜ë¦¬ (íšŒì „ ë©ˆì¶¤)
      document.addEventListener('keyup', function(event) {
        if (event.key === 'ArrowLeft') {
          isRotatingLeft = false;
        } else if (event.key === 'ArrowRight') {
          isRotatingRight = false;
        }
      });

      // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // íˆ¬ëª… ë°°ê²½

        // ì¼ë°˜ ê¸€ì ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸° (ë§¨ ì•„ë˜)
        letters.forEach(letter => {
          letter.update();
          letter.draw();
        });

        // ì‚¬ë¼ì§„ ê¸€ì ì œê±°
        letters = letters.filter(letter => !letter.isFinished());
        
        // ë§ˆì§€ë§‰ ì…ë ¥ìœ¼ë¡œë¶€í„° 2ì´ˆ ì´ìƒ ì§€ë‚¬ìœ¼ë©´ íƒ€ì´í•‘ ìƒíƒœ í•´ì œ (ê¸€ìê°€ ë‚¨ì•„ìˆì–´ë„)
        const timeSinceLastInput = Date.now() - lastInputTime;
        if (timeSinceLastInput > 2000) {
          isTyping = false;
        }
        
        // ëª¨ë“  ê¸€ìê°€ ì‚¬ë¼ì¡Œìœ¼ë©´ íƒ€ì´í•‘ ìƒíƒœ í•´ì œ
        if (letters.length === 0) {
          isTyping = false;
        }

        // ì¤‘ê°„ ë©”ì‹œì§€ ë Œë”ë§ ("Wish for a new world...") - ì»¤íŠ¼ê³¼ í•¨ê»˜ ë“œëŸ¬ë‚¨
        if (introMessage && introMessage.length > 0) {
          const timeSinceExplosion = (Date.now() - explosionStartTime) / 1000;
          
          introMessage.forEach((msgLetter, index) => {
            msgLetter.update();
            
            // ì»¤íŠ¼ì´ ì§€ë‚˜ê°„ í›„ ìˆœì°¨ì ìœ¼ë¡œ ë“œëŸ¬ë‚¨ (ì˜¤ë¥¸ìª½â†’ì™¼ìª½, íŒŒíŠ¸ë³„ ì‹œì°¨)
            if (timeSinceExplosion > msgLetter.revealDelay && !msgLetter.revealed) {
              msgLetter.revealed = true;
              if (index % 10 === 0) { // ë§¤ 10ë²ˆì§¸ ê¸€ìë§ˆë‹¤ ë¡œê·¸
                console.log(`âœ¨ Revealing intro part ${msgLetter.introPart} at ${timeSinceExplosion.toFixed(1)}s`);
              }
            }
            
            // ë“œëŸ¬ë‚œ ê¸€ì í˜ì´ë“œì¸
            if (msgLetter.revealed) {
              msgLetter.particles.forEach(p => {
                if (p.alpha < p.targetAlpha) {
                  p.alpha += 0.03; // ë¹ ë¥´ê²Œ ë‚˜íƒ€ë‚¨
                }
              });
            }
            
            // disperseTimeì— ë„ë‹¬í•˜ë©´ ë‚ ì•„ê°
            if (timeSinceExplosion > msgLetter.disperseTime && !msgLetter.dispersing) {
              msgLetter.dispersing = true;
              msgLetter.particles.forEach(p => {
                p.dispersing = true;
                p.velocityX = (Math.random() - 0.5) * 3;
                p.velocityY = (Math.random() - 0.5) * 3 - 2; // ìœ„ë¡œ ë‚ ì•„ê°
              });
            }
            
            msgLetter.draw();
          });
          
          // ëª¨ë“  ê¸€ìê°€ ì‚¬ë¼ì¡ŒëŠ”ì§€ í™•ì¸
          const allGone = introMessage.every(letter => 
            letter.particles.every(p => p.alpha <= 0)
          );
          
          if (allGone && timeSinceExplosion > 9.0) {
            introMessage = null; // ì •ë¦¬
          }
        }
        
        // "Make your wish" ë©”ì‹œì§€ ë Œë”ë§ (ìˆœì°¨ì  ë“œëŸ¬ë‚¨ + ì¼ë ì„) - ì¤‘ê°„ ë ˆì´ì–´
        if (wishMessage && wishMessage.length > 0) {
          const timeSinceExplosion = (Date.now() - explosionStartTime) / 1000;
          
          wishMessage.forEach((msgLetter, index) => {
            // update í˜¸ì¶œ
            msgLetter.update();
            
            // 8.2ì´ˆ ì´í›„ ìˆœì°¨ì ìœ¼ë¡œ ë“œëŸ¬ë‚¨ (introMessage ë‚ ì•„ê°€ë©´ì„œ, ì‚´ì§ ëŠ¦ê²Œ)
            const revealStartTime = 8.2;
            const timeSinceRevealStart = timeSinceExplosion - revealStartTime;
            
            if (timeSinceRevealStart > msgLetter.revealDelay) {
              // ë“œëŸ¬ë‚˜ê¸° ì‹œì‘
              if (!msgLetter.revealed) {
                msgLetter.revealed = true;
              }
              
              // íŒŒí‹°í´ ì•ŒíŒŒ ì¦ê°€ (í˜ì´ë“œì¸)
              msgLetter.particles.forEach(p => {
                if (p.alpha < p.targetAlpha) {
                  p.alpha += 0.03; // ë¹ ë¥´ê²Œ ë‚˜íƒ€ë‚¨
                }
              });
            }
            
            // ì¼ë ì´ëŠ” íš¨ê³¼ (ë“œëŸ¬ë‚œ ê¸€ìë§Œ)
            if (msgLetter.revealed) {
              const waveOffset = Math.sin(Date.now() * 0.002 + index * 0.3) * 5;
              
              msgLetter.particles.forEach(p => {
                p.y = p.originalY + waveOffset;
              });
            }
            
            msgLetter.draw();
          });
        }
        
        // í•œê¸€ ê²½ê³  ë©”ì‹œì§€ ë Œë”ë§ (ì™¼ìª½â†’ì˜¤ë¥¸ìª½ ìˆœì°¨ ë“±ì¥, ìœ ì§€, ë‚ ì•„ê°€ê¸°)
        if (koreanWarningMessage && koreanWarningMessage.length > 0) {
          const timeSinceWarning = Date.now() - koreanWarningStartTime;
          
          // ë§ˆì§€ë§‰ ê¸€ìì˜ revealDelay ê³„ì‚°
          const lastLetterRevealDelay = Math.max(...koreanWarningMessage.map(l => l.revealDelay));
          
          koreanWarningMessage.forEach((msgLetter, index) => {
            msgLetter.update();
            
            // ìˆœì°¨ì ìœ¼ë¡œ ë“œëŸ¬ë‚¨ (ì™¼ìª½â†’ì˜¤ë¥¸ìª½)
            if (timeSinceWarning > msgLetter.revealDelay && !msgLetter.revealed) {
              msgLetter.revealed = true;
              console.log(`Revealing Korean warning letter ${index}: "${msgLetter.char}"`);
            }
            
            // ë“œëŸ¬ë‚œ ê¸€ì í˜ì´ë“œì¸
            if (msgLetter.revealed) {
              msgLetter.particles.forEach(p => {
                // ë‚ ì•„ê°€ì§€ ì•ŠëŠ” íŒŒí‹°í´ë§Œ í˜ì´ë“œì¸ ì ìš©
                if (!p.dispersing && p.alpha < p.targetAlpha) {
                  p.alpha += 0.04; // ë¹ ë¥´ê²Œ ë‚˜íƒ€ë‚¨
                }
              });
            }
            
            // ë§ˆì§€ë§‰ ê¸€ìê°€ ë“œëŸ¬ë‚œ í›„ 3ì´ˆ í›„ ë‚ ì•„ê°€ê¸° ì‹œì‘
            const disperseStartTime = lastLetterRevealDelay + 3000;
            if (timeSinceWarning > disperseStartTime && msgLetter.revealed && !msgLetter.dispersed) {
              msgLetter.dispersed = true;
              // ê¸€ìì˜ x ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ë¶€í„° ë‚ ì•„ê°€ë„ë¡ (ì¼ë°˜ ê¸€ìì™€ ë™ì¼)
              msgLetter.particles.forEach(p => p.disperse(msgLetter.x));
              console.log(`Korean warning letter ${index} starting to disperse`);
            }
            
            msgLetter.draw();
          });
          
          // ëª¨ë“  ê¸€ìê°€ ì™„ì „íˆ ì‚¬ë¼ì¡Œìœ¼ë©´ ì •ë¦¬
          const allGone = koreanWarningMessage.every(letter => 
            letter.particles.every(p => p.alpha <= 0)
          );
          
          if (allGone) {
            koreanWarningMessage = null;
            console.log('ğŸ—‘ï¸ Korean warning message cleared');
          }
        }
        
        // touch íŒíŠ¸ ë©”ì‹œì§€ ë Œë”ë§ (í•œê¸€ íŒíŠ¸ì™€ ë™ì¼í•œ ë¡œì§)
        if (touchHintMessage && touchHintMessage.length > 0) {
          const timeSinceHint = Date.now() - touchHintStartTime;
          
          // ë§ˆì§€ë§‰ ê¸€ìì˜ revealDelay ê³„ì‚°
          const lastLetterRevealDelay = Math.max(...touchHintMessage.map(l => l.revealDelay));
          
          touchHintMessage.forEach((msgLetter, index) => {
            msgLetter.update();
            
            // ìˆœì°¨ì ìœ¼ë¡œ ë“œëŸ¬ë‚¨
            if (timeSinceHint > msgLetter.revealDelay && !msgLetter.revealed) {
              msgLetter.revealed = true;
              console.log(`Revealing touch hint letter ${index}: "${msgLetter.char}"`);
            }
            
            // ë“œëŸ¬ë‚œ ê¸€ì í˜ì´ë“œì¸
            if (msgLetter.revealed) {
              msgLetter.particles.forEach(p => {
                // ë‚ ì•„ê°€ì§€ ì•ŠëŠ” íŒŒí‹°í´ë§Œ í˜ì´ë“œì¸ ì ìš©
                if (!p.dispersing && p.alpha < p.targetAlpha) {
                  p.alpha += 0.03; // ë¹ ë¥´ê²Œ ë‚˜íƒ€ë‚¨
                }
              });
            }
            
            // ë§ˆì§€ë§‰ ê¸€ìê°€ ë“œëŸ¬ë‚œ í›„ 3ì´ˆ í›„ ë‚ ì•„ê°€ê¸° ì‹œì‘
            const disperseStartTime = lastLetterRevealDelay + 3000;
            if (timeSinceHint > disperseStartTime && msgLetter.revealed && !msgLetter.dispersed) {
              msgLetter.dispersed = true;
              // ê¸€ìì˜ x ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ë¶€í„° ë‚ ì•„ê°€ë„ë¡ (ì¼ë°˜ ê¸€ìì™€ ë™ì¼)
              msgLetter.particles.forEach(p => p.disperse(msgLetter.x));
              console.log(`Touch hint letter ${index} starting to disperse`);
            }
            
            msgLetter.draw();
          });
          
          // ëª¨ë“  ê¸€ìê°€ ì™„ì „íˆ ì‚¬ë¼ì¡Œìœ¼ë©´ ì •ë¦¬
          const allGone = touchHintMessage.every(letter => 
            letter.particles.every(p => p.alpha <= 0)
          );
          
          if (allGone) {
            touchHintMessage = null;
            console.log('ğŸ’¡ Touch hint message cleared');
          }
        }
        
        // í´ë¦­ íŒíŠ¸ ë©”ì‹œì§€ ë Œë”ë§ (í•œê¸€ íŒíŠ¸ì™€ ë™ì¼í•œ ë¡œì§)
        if (clickHintMessage && clickHintMessage.length > 0) {
          const timeSinceHint = Date.now() - clickHintStartTime;
          
          // ë§ˆì§€ë§‰ ê¸€ìì˜ revealDelay ê³„ì‚°
          const lastLetterRevealDelay = Math.max(...clickHintMessage.map(l => l.revealDelay));
          
          clickHintMessage.forEach((msgLetter, index) => {
            msgLetter.update();
            
            // ìˆœì°¨ì ìœ¼ë¡œ ë“œëŸ¬ë‚¨
            if (timeSinceHint > msgLetter.revealDelay && !msgLetter.revealed) {
              msgLetter.revealed = true;
              console.log(`Revealing click hint letter ${index}: "${msgLetter.char}"`);
            }
            
            // ë“œëŸ¬ë‚œ ê¸€ì í˜ì´ë“œì¸
            if (msgLetter.revealed) {
              msgLetter.particles.forEach(p => {
                // ë‚ ì•„ê°€ì§€ ì•ŠëŠ” íŒŒí‹°í´ë§Œ í˜ì´ë“œì¸ ì ìš©
                if (!p.dispersing && p.alpha < p.targetAlpha) {
                  p.alpha += 0.03; // ë¹ ë¥´ê²Œ ë‚˜íƒ€ë‚¨
                }
              });
            }
            
            // ë§ˆì§€ë§‰ ê¸€ìê°€ ë“œëŸ¬ë‚œ í›„ 3ì´ˆ í›„ ë‚ ì•„ê°€ê¸° ì‹œì‘
            const disperseStartTime = lastLetterRevealDelay + 3000;
            if (timeSinceHint > disperseStartTime && msgLetter.revealed && !msgLetter.dispersed) {
              msgLetter.dispersed = true;
              // ê¸€ìì˜ x ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ë¶€í„° ë‚ ì•„ê°€ë„ë¡ (ì¼ë°˜ ê¸€ìì™€ ë™ì¼)
              msgLetter.particles.forEach(p => p.disperse(msgLetter.x));
              console.log(`Click hint letter ${index} starting to disperse`);
            }
            
            msgLetter.draw();
          });
          
          // ëª¨ë“  ê¸€ìê°€ ì™„ì „íˆ ì‚¬ë¼ì¡Œìœ¼ë©´ ì •ë¦¬
          const allGone = clickHintMessage.every(letter => 
            letter.particles.every(p => p.alpha <= 0)
          );
          
          if (allGone) {
            clickHintMessage = null;
            console.log('ğŸ’¡ Click hint message cleared');
          }
        }
        
        // Enter íŒíŠ¸ ë©”ì‹œì§€ ë Œë”ë§ (í•œê¸€ íŒíŠ¸ì™€ ë™ì¼í•œ ë¡œì§)
        if (enterHintMessage && enterHintMessage.length > 0) {
          const timeSinceHint = Date.now() - enterHintStartTime;
          
          // ë§ˆì§€ë§‰ ê¸€ìì˜ revealDelay ê³„ì‚°
          const lastLetterRevealDelay = Math.max(...enterHintMessage.map(l => l.revealDelay));
          
          enterHintMessage.forEach((msgLetter, index) => {
            msgLetter.update();
            
            // ìˆœì°¨ì ìœ¼ë¡œ ë“œëŸ¬ë‚¨
            if (timeSinceHint > msgLetter.revealDelay && !msgLetter.revealed) {
              msgLetter.revealed = true;
              console.log(`Revealing Enter hint letter ${index}: "${msgLetter.char}"`);
            }
            
            // ë“œëŸ¬ë‚œ ê¸€ì í˜ì´ë“œì¸
            if (msgLetter.revealed) {
              msgLetter.particles.forEach(p => {
                // ë‚ ì•„ê°€ì§€ ì•ŠëŠ” íŒŒí‹°í´ë§Œ í˜ì´ë“œì¸ ì ìš©
                if (!p.dispersing && p.alpha < p.targetAlpha) {
                  p.alpha += 0.03; // ë¹ ë¥´ê²Œ ë‚˜íƒ€ë‚¨
                }
              });
            }
            
            // ë§ˆì§€ë§‰ ê¸€ìê°€ ë“œëŸ¬ë‚œ í›„ 3ì´ˆ í›„ ë‚ ì•„ê°€ê¸° ì‹œì‘
            const disperseStartTime = lastLetterRevealDelay + 3000;
            if (timeSinceHint > disperseStartTime && msgLetter.revealed && !msgLetter.dispersed) {
              msgLetter.dispersed = true;
              // ê¸€ìì˜ x ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ë¶€í„° ë‚ ì•„ê°€ë„ë¡ (ì¼ë°˜ ê¸€ìì™€ ë™ì¼)
              msgLetter.particles.forEach(p => p.disperse(msgLetter.x));
              console.log(`Enter hint letter ${index} starting to disperse`);
            }
            
            msgLetter.draw();
          });
          
          // ëª¨ë“  ê¸€ìê°€ ì™„ì „íˆ ì‚¬ë¼ì¡Œìœ¼ë©´ ì •ë¦¬
          const allGone = enterHintMessage.every(letter => 
            letter.particles.every(p => p.alpha <= 0)
          );
          
          if (allGone) {
            enterHintMessage = null;
            console.log('ğŸ’¡ Enter hint message cleared');
          }
        }

        // ëª¨ë˜ ì»¤íŠ¼ ì• ë‹ˆë©”ì´ì…˜ (í™”ë©´ ì „í™˜ íš¨ê³¼) - ë§¨ ìœ„ ë ˆì´ì–´
        if (isExploding || explosionParticles.length > 0 || introMessage || wishMessage) {
          const explosionElapsed = (Date.now() - explosionStartTime) / 1000;
          
          // ë””ë²„ê¹…: íƒ€ì´ë° ë¡œê·¸ (5ì´ˆë§ˆë‹¤)
          if (Math.floor(explosionElapsed) % 5 === 0 && Math.floor(explosionElapsed * 10) % 50 === 0) {
            console.log(`â±ï¸ Time: ${explosionElapsed.toFixed(1)}s, introMessage: ${introMessage ? 'exists' : 'null'}, wishMessage: ${wishMessage ? 'exists' : 'null'}`);
          }
          
          // ì£¼ë‘¥ì´ì—ì„œ ê³„ì† íŒŒí‹°í´ ìƒì„± (ì²˜ìŒ 1.5ì´ˆ ë™ì•ˆ - ë” ê¸¸ê²Œ)
          if (explosionElapsed < 1.5) {
            // ê³ ì •ëœ í™”ë©´ ì¢Œí‘œ ì‚¬ìš© (ì£¼ë‘¥ì´ ë ìœ„ì¹˜)
            const spoutX = 469;
            const spoutY = 325; // ì•„ì£¼ ì‚´ì§ ìœ„ë¡œ (329 â†’ 325)
            
            // ì™¼ìª½ìœ¼ë¡œ ë‚˜ê°€ë„ë¡ ê³ ì • (ì£¼ë‘¥ì´ê°€ ì™¼ìª½ì„ í–¥í•¨)
            const direction = -1;
            
            // ë§¤ í”„ë ˆì„ë§ˆë‹¤ íŒŒí‹°í´ ìƒì„± (2ë°°ë¡œ!)
            for (let i = 0; i < 200; i++) {
              // ì£¼ë‘¥ì´ ì…êµ¬ì—ì„œ ì‹œì‘ (ì™„ì „íˆ í•œ ì ì—ì„œ)
              const offsetX = 0;
              const offsetY = 0;
              const startX = spoutX + offsetX;
              const startY = spoutY + offsetY;
              
              // ë§¤ìš° ì§§ì€ ë”œë ˆì´ë¡œ ë¾°ì¡±í•˜ê²Œ (ì‚¼ê°í˜• ëì²˜ëŸ¼)
              const spawnDelay = Math.random() * 600; // 0~50ms (ë§¤ìš° ì§§ê²Œ)
              
              explosionParticles.push(new SandCurtainParticle(startX, startY, direction, spawnDelay));
            }
          }
          
          // íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
          explosionParticles.forEach(p => {
            p.update();
            p.draw(ctx);
          });
          
          // ì£½ì€ íŒŒí‹°í´ ì œê±°
          explosionParticles = explosionParticles.filter(p => !p.isDead());
          
          // 0.3ì´ˆ í›„ ì¤‘ê°„ ë©”ì‹œì§€ ìƒì„± (ì»¤íŠ¼ê³¼ í•¨ê»˜ ë“œëŸ¬ë‚¨)
          if (explosionElapsed > 0.3 && !introMessage && !wishMessage) {
            console.log('ğŸŒŸ Creating intro message with curtain!');
            
            introMessage = [];
            
            // 3ê°œ íŒŒíŠ¸ë¡œ ë‚˜ëˆ” (ì‰¼í‘œ ê¸°ì¤€)
            const introParts = [
              "Wish for a new world",
              "a thousand new things",
              "or just a fabulous new look"
            ];
            
            // ë¨í”„ ì•„ë˜ ì¤‘ì•™ì— 3ì¤„ë¡œ ë°°ì¹˜ (ì‘ì€ ê¸€ì”¨)
            const baseY = window.innerHeight * 0.62; // ë¨í”„ ì•„ë˜ (ë” ìœ„ë¡œ ì˜¬ë¦¼)
            const lineHeight = 65; // ì¤„ ê°„ê²© (ì¡°ê¸ˆ ë” ëŠ˜ë¦¼)
            
            introParts.forEach((text, partIndex) => {
              const y = baseY + lineHeight * partIndex;
              
              // ë¨¼ì € x=0ë¶€í„° ì‹œì‘í•´ì„œ Letter ìƒì„±í•˜ê³  ë„ˆë¹„ ê³„ì‚°
              let currentX = 0;
              const partStartX = 0;
              const partLetters = [];
              
              for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const msgLetter = new Letter(char, currentX, y, i, 55); // ì‘ì€ ê¸€ì”¨ (55px)
                msgLetter.isIntroMessage = true;
                msgLetter.introPart = partIndex;
                msgLetter.disperseTime = 8.0; // 8ì´ˆì— ëª¨ë‘ ë‚ ì•„ê°
                msgLetter.revealed = false;
                
                // ëª¨ë“  íŒŒí‹°í´ì„ íˆ¬ëª…í•˜ê²Œ ì‹œì‘ + í™©ê¸ˆìƒ‰ìœ¼ë¡œ ì„¤ì • (ì§€ë‹ˆ ë©”ì‹œì§€)
                msgLetter.particles.forEach(p => {
                  p.alpha = 0;
                  p.targetAlpha = 1;
                  p.forming = false;
                  // í™©ê¸ˆìƒ‰ íŒŒí‹°í´ë¡œ ë³€ê²½
                  p.color = `hsl(45, 85%, ${Math.random() * 15 + 60}%)`; // í™©ê¸ˆìƒ‰ (60~75% ë°ê¸°)
                });
                
                partLetters.push(msgLetter);
                const spacing = char === ' ' ? 22 : Math.min(Math.max(msgLetter.width + 8, 30), 37); // ìê°„ ì¡°ê¸ˆ ë” í‚¤ì›€
                currentX += spacing;
              }
              
              // ì „ì²´ ë„ˆë¹„ ê³„ì‚° ì™„ë£Œ
              const totalWidth = currentX;
              
              // ì¤‘ì•™ì •ë ¬ì„ ìœ„í•´ ëª¨ë“  Letterì˜ x ìœ„ì¹˜ë¥¼ ì˜¤í”„ì…‹ (ì‚´ì§ ì˜¤ë¥¸ìª½ìœ¼ë¡œ)
              const offsetX = (window.innerWidth - totalWidth) / 2 + 30;
              partLetters.forEach((msgLetter) => {
                msgLetter.x += offsetX;
                msgLetter.partStartX = offsetX;
                // íŒŒí‹°í´ ìœ„ì¹˜ë„ ì—…ë°ì´íŠ¸
                msgLetter.particles.forEach(p => {
                  p.x += offsetX;
                  p.originalX += offsetX;
                });
              });
              
              // introMessageì— ì¶”ê°€
              introMessage.push(...partLetters);
              
              // revealDelay ì„¤ì • (ì™¼ìª½â†’ì˜¤ë¥¸ìª½)
              partLetters.forEach((msgLetter) => {
                const relativeX = msgLetter.x - offsetX;
                const normalizedX = relativeX / totalWidth; // 0(ì™¼ìª½)~1(ì˜¤ë¥¸ìª½)
                // íŒŒíŠ¸ë³„ë¡œ 2ì´ˆ ê°„ê²© (2ì´ˆ, 4ì´ˆ, 6ì´ˆ)
                const partRevealStartTime = 2.0 + partIndex * 2.0;
                // ì™¼ìª½â†’ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë“œëŸ¬ë‚¨
                msgLetter.revealDelay = partRevealStartTime + normalizedX * 0.8;
              });
            });
            
            console.log('âœ¨ introMessage created (will reveal with curtain sweep)!');
          }
          
          // 8.0ì´ˆ í›„ "Make your wish" ë©”ì‹œì§€ ìƒì„± (introMessageê°€ ë‚ ì•„ê°€ë©´ì„œ)
          if (explosionElapsed > 8.0 && introMessage && !wishMessage) {
            console.log('ğŸŒŸ Creating "Make your wish" message!');
            
            wishMessage = [];
            const message = "Make your wish";
            const msgY = window.innerHeight * 0.65;
            
            // ë¨¼ì € ì „ì²´ ë„ˆë¹„ ê³„ì‚°
            const tempCanvas2 = document.createElement('canvas');
            const tempCtx2 = tempCanvas2.getContext('2d');
            tempCtx2.font = `italic bold 80px 'Cormorant Garamond', serif`;
            
            let totalMsgWidth = 0;
            for (let i = 0; i < message.length; i++) {
              const char = message[i];
              const metrics = tempCtx2.measureText(char);
              const spacing = char === ' ' ? 25 : Math.min(Math.max(metrics.width + 8, 45), 58);
              totalMsgWidth += spacing;
            }
            
            // ì¤‘ì•™ì •ë ¬ ì‹œì‘ ìœ„ì¹˜ (ì‚´ì§ ì˜¤ë¥¸ìª½ìœ¼ë¡œ)
            const msgX = (window.innerWidth - totalMsgWidth) / 2 + 50;
            let msgCurrentX = msgX;
            
            for (let i = 0; i < message.length; i++) {
              const char = message[i];
              const msgLetter = new Letter(char, msgCurrentX, msgY, i);
              msgLetter.isWishMessage = true;
              msgLetter.revealDelay = 0; // ë‚˜ì¤‘ì— ì„¤ì •
              msgLetter.revealed = false;
              
              msgLetter.particles.forEach(p => {
                p.alpha = 0;
                p.targetAlpha = 1;
                p.forming = false;
                // í™©ê¸ˆìƒ‰ íŒŒí‹°í´ë¡œ ë³€ê²½ (ì§€ë‹ˆ ë©”ì‹œì§€)
                p.color = `hsl(45, 85%, ${Math.random() * 15 + 60}%)`; // í™©ê¸ˆìƒ‰ (60~75% ë°ê¸°)
              });
              
              wishMessage.push(msgLetter);
              const spacing = char === ' ' ? 25 : Math.min(Math.max(msgLetter.width + 8, 45), 58);
              msgCurrentX += spacing;
            }
            
            // ì™¼ìª½ë¶€í„° ë“œëŸ¬ë‚˜ë„ë¡ ë”œë ˆì´ ì„¤ì •
            const totalWidth = msgCurrentX - msgX;
            wishMessage.forEach((msgLetter) => {
              const letterX = msgLetter.x;
              const relativeX = letterX - msgX;
              const normalizedX = relativeX / totalWidth; // 0(ì™¼ìª½)~1(ì˜¤ë¥¸ìª½)
              // ì™¼ìª½ë¶€í„° ë“œëŸ¬ë‚¨
              msgLetter.revealDelay = normalizedX * 0.8;
            });
            
            console.log('âœ¨ wishMessage created!');
          }
          
          // wishMessageê°€ ìƒì„±ëœ í›„ì—ë§Œ ì¢…ë£Œ
          if (explosionElapsed > 9.0 && explosionParticles.length === 0 && wishMessage) {
            if (isExploding) { // ìƒíƒœê°€ ë³€ê²½ë  ë•Œë§Œ ë¡œê·¸ ì¶œë ¥
              console.log('ğŸ¬ Animation sequence completed!');
            }
            isExploding = false;
          }
        }

        // íƒ€ì´í•‘ ì¤‘ì´ ì•„ë‹ˆë©´ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ë”°ë¼ê°
        if (!isTyping) {
          currentX = mouseX;
          currentY = mouseY;
        }

        requestAnimationFrame(animate);
      }

      animate();

      // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
      window.addEventListener('resize', () => {
        // Three.js ë¦¬ì‚¬ì´ì¦ˆ
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // 2D ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // ë°°ê²½ ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;
        
        // ë°°ê²½ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
        if (currentBackgroundImage) {
          const bgImage = new Image();
          bgImage.crossOrigin = 'anonymous';
          bgImage.onload = function() {
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            bgCtx.drawImage(bgImage, 0, 0, bgCanvas.width, bgCanvas.height);
            bgImageData = bgCtx.getImageData(0, 0, bgCanvas.width, bgCanvas.height);
          };
          bgImage.src = currentBackgroundImage;
        }
      });
    </script>
  </body>
</html>
